## 前提・要約
- 目的：Tesseract.js のOCR結果（テキスト＋信頼度）から、血圧値（最高/最低）と脈拍を高い再現性で抽出し、後続（Step 3-4）の自動入力に渡せるようにする。
- 成果物：`js/ocr.js` に「血圧値抽出」モジュール（関数群）を実装し、代表的なOCR出力パターンに対して抽出の自己テスト（簡易フィクスチャ）を用意する。
- 対象の種類（推定）：新規実装（OCRフェーズの中核ロジック追加）。
- 成功条件（Done）：
  - 最高/最低/脈拍を、入力テキストの揺れ（改行・空白・誤認識）を吸収しつつ抽出できる。
  - 抽出値のバリデーション（範囲・大小関係）が通り、複数候補がある場合に合理的な選択（スコアリング）ができる。
  - 抽出失敗/低信頼度時に、後続UIが扱えるエラー/警告情報を返せる。
  - 代表的なサンプル（最低5〜10ケース）で期待通りの結果になる。
- 前提（仮定した点があれば明記）：
  - Step 3-1/3-2 が完了しており、`recognizeText()` から `result.data.text` と（可能なら）`result.data.words/lines` の信頼度情報を受け取れる。
  - 血圧計の表示は主に数字で、血圧は 2〜3桁、脈拍は 2〜3桁である。
- 主要な制約：
  - ブラウザ上で動作（PWA/バンドルなし）。重い処理や依存追加は避け、文字列処理中心で完結させる。
  - OCRは誤認識が前提（例：`O→0`、`I/l→1`、`S→5`、`/` が欠落・別記号になる等）。
- 既知の不明点（あれば）：
  - 実際に使う血圧計の表示レイアウト（上下配置、区切り記号、ラベル有無）が確定していないため、汎用パターン優先で作る（不足は Step 3-5 の最適化で補う）。

## 全体ステップ構成
- Step1: 抽出I/Fとデータ構造の設計（どの入力を受け、何を返すか）
- Step2: テキスト正規化（ノイズ除去・誤認識補正）
- Step3: 候補抽出（血圧ペア/脈拍）
- Step4: 候補選別（バリデーション＋スコアリング）
- Step5: 自己テスト（フィクスチャ）＋デバッグ観点の仕込み

---

## Step1: 抽出I/Fとデータ構造の設計
### Plan 1: 抽出関数のインターフェース確定
- 目的：後続（Step 3-4）で安全に扱える戻り値仕様を先に固め、実装の迷いを減らす。
- 作業内容（チェックリスト）：
  - [ ] `extractVitalsFromOcr(result)` の入力形式を定義（`result.data.text`/`words`/`lines` を使う前提を明文化）
  - [ ] 戻り値スキーマを決める（例）
    - `systolic`, `diastolic`, `pulse`（数値 or `null`）
    - `confidence`（0-100）＋ `fieldConfidence`（各項目）
    - `rawText`（生テキスト）
    - `warnings[]`（低信頼度、候補複数、矛盾など）
    - `errors[]`（抽出不能、バリデーションNGなど）
  - [ ] 低信頼度閾値（例：70%）や「警告」扱いの基準を決める
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`（抽出関数と型相当のコメント）
- 受け入れ基準（完了条件）：
  - 関数I/Fがコメントで明確で、UI側が `null` や `warnings/errors` を見て分岐できる。
- テスト/検証：
  - ブラウザconsoleで空/異常入力を与えても例外で落ちず、スキーマ通り返る。
- 依存関係・注意点：
  - Tesseractの戻り値（`words`等）の有無は環境で変わる可能性があるため、`text`のみでも動くフォールバックを必須にする。
- リスクと回避策：
  - リスク：I/Fが曖昧で後工程のUI実装が詰まる
  - 回避策：`null`の扱い、警告/エラーの粒度を先に定義して固定する

---

## Step2: テキスト正規化（ノイズ除去・誤認識補正）
### Plan 1: 正規化パイプラインの実装方針策定
- 目的：OCR特有のブレを吸収し、後段の正規表現/トークン処理を安定させる。
- 作業内容（チェックリスト）：
  - [ ] 正規化関数 `normalizeOcrText(rawText)` を定義
  - [ ] 変換ルールを決める（例）
    - 全角数字→半角数字
    - 似た文字補正：`O/〇→0`、`I/l/|→1`、`S→5`（過補正を避けるため数字近傍のみ適用）
    - 区切りの統一：`／` `\` `|` `｜` `:` などを候補として `/` に寄せる（状況依存で）
    - 余分な記号・重複スペースの除去、改行の扱い（`\n`をスペースに寄せる等）
  - [ ] 「元テキスト」と「正規化後テキスト」の両方を保持する方針にする（デバッグ用）
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`（正規化関数）
- 受け入れ基準（完了条件）：
  - 正規化後テキストで、数字トークン抽出が安定する（全角・記号揺れの影響が小さい）。
- テスト/検証：
  - 手書きのサンプル文字列（全角/誤認識含む）で正規化が期待通り。
- 依存関係・注意点：
  - 過補正（例：ラベル文字の一部を数字にしてしまう）に注意。数字の近傍に限定するなどガードを入れる。
- リスクと回避策：
  - リスク：補正が強すぎて誤抽出が増える
  - 回避策：補正前後を比較できるよう `debug.normalizedText` を返却可能にする（フラグ制御）

---

## Step3: 候補抽出（血圧ペア/脈拍）
### Plan 1: 血圧ペア候補の抽出実装
- 目的：最重要の「最高/最低」を複数パターンで候補として拾い漏れを減らす。
- 作業内容（チェックリスト）：
  - [ ] 主要パターン：`XXX/YYY` を正規表現で抽出（2〜3桁）
  - [ ] 区切り欠落パターン：`XXX YYY`（スペース/改行区切り）を検出
  - [ ] 上下配置/連続数字パターン：数値トークン列から「妥当な2値組」を列挙（近接優先）
  - [ ] （可能なら）`words/lines` から近接情報・confidenceを引き継ぎ、候補にメタ情報を持たせる
    - 例：`{sys, dia, scoreBase, confSys, confDia, evidence}`
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`（`extractBpCandidates()`）
- 受け入れ基準（完了条件）：
  - 典型パターン（`120/80`、`120 80`、改行で分断）で候補が生成される。
- テスト/検証：
  - サンプルテキストで候補の配列が期待通り（件数・値）になる。
- 依存関係・注意点：
  - 血圧計によってはラベル（SYS/DIA等）や単位表記が混在。ラベルに引っ張られず数字中心で拾う。
- リスクと回避策：
  - リスク：余計な2値組が大量に出る
  - 回避策：バリデーション（範囲）を早期に適用し、候補数を抑える

### Plan 2: 脈拍候補の抽出実装
- 目的：血圧と混同しやすい「脈拍」を、ラベル/単位も使って安定抽出する。
- 作業内容（チェックリスト）：
  - [ ] まず血圧候補で採用されうる数字（sys/dia）を除外した上で、残りの2〜3桁数字を列挙
  - [ ] ラベル優先：`PUL`, `Pulse`, `HR`, `bpm`, `脈拍` などの近傍にある数字を優先候補にする（`text`ベースでも `words`ベースでも可）
  - [ ] ラベルが無い場合のフォールバック：範囲（40-200）＋ confidence の高いものを採用
  - [ ] 候補のメタ情報（confidence、ラベル近接度）を保持
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`（`extractPulseCandidates()`）
- 受け入れ基準（完了条件）：
  - 血圧の数字と別の脈拍があるテキストで、脈拍候補が適切に出る。
- テスト/検証：
  - `120/80 65` や `SYS 120 DIA 80 PUL 65` などで脈拍=65が候補に入る。
- 依存関係・注意点：
  - `bpm` 等の単位が誤認識されやすいので、単位に依存しすぎない。
- リスクと回避策：
  - リスク：血圧の片方を脈拍として誤採用
  - 回避策：採用済みsys/diaと同値を除外、または同一ブロック内の配置/ラベルで判定

---

## Step4: 候補選別（バリデーション＋スコアリング）
### Plan 1: バリデーションの実装（範囲・関係）
- 目的：明らかな誤抽出を排除し、後段のスコアリングを簡素化する。
- 作業内容（チェックリスト）：
  - [ ] 最高血圧：50-250、最低血圧：30-150、脈拍：40-200 の範囲チェック
  - [ ] `systolic > diastolic` を必須条件にする（差が極端に小さい場合は警告）
  - [ ] 値が見つからない/矛盾する場合は `errors[]` に理由コードを積む（UIで表示可能に）
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`（`validateVitals()`）
- 受け入れ基準（完了条件）：
  - 範囲外値が除外され、返却時に `null` と `errors/warnings` が整合する。
- テスト/検証：
  - `999/10` や `80/120` 等で不採用/エラーになる。
- 依存関係・注意点：
  - 例外を投げずに「結果オブジェクト＋errors」で返す方がUI連携が楽。
- リスクと回避策：
  - リスク：厳しすぎて拾えるケースが減る
  - 回避策：厳密NG（error）と注意（warning）を分ける（例：差が小さい→warning）

### Plan 2: スコアリングと最適候補の決定
- 目的：複数候補が出たときに、最も妥当な組み合わせを安定して選べるようにする。
- 作業内容（チェックリスト）：
  - [ ] 血圧ペアのスコア設計（例）
    - `score = confAvg + bonus(validRange) + bonus(hasSeparatorOrLabel) + bonus(reasonableGap) - penalty(outlier)`
  - [ ] 脈拍のスコア設計（ラベル近接度＋confidence＋範囲）
  - [ ] 採用結果に `fieldConfidence` を付与し、総合 `confidence` を算出
  - [ ] 低信頼度/候補僅差/候補多数の場合は `warnings[]` を付与
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`（`selectBestBpCandidate()` / `selectBestPulseCandidate()` / `computeOverallConfidence()`）
- 受け入れ基準（完了条件）：
  - 複数候補テキストで、期待する候補（範囲内・高confidence・ラベル近傍）が選ばれる。
- テスト/検証：
  - フィクスチャで「候補が2つある」ケースを用意し、期待どおりの選択を確認。
- 依存関係・注意点：
  - スコアは Step 3-5 で調整しやすいよう、定数/関数に分離する。
- リスクと回避策：
  - リスク：機種差でスコアが偏る
  - 回避策：証拠（どのルールで勝ったか）を `debug.evidence` に保持できる設計にする（本番ではオフ）

---

## Step5: 自己テスト（フィクスチャ）＋デバッグ観点の仕込み
### Plan 1: フィクスチャ駆動の簡易テストを追加
- 目的：ブラウザだけで再現できる形で、抽出ロジックの回帰を防ぐ。
- 作業内容（チェックリスト）：
  - [ ] `fixtures`（配列）として、OCR出力文字列と期待値を5〜10ケース用意
    - 例：`"120/80 65"`、`"SYS 120 DIA 80 PUL 65"`、全角混在、`/`欠落、改行分断、誤認識（O→0）など
  - [ ] `runExtractionSelfTest()` を用意し、consoleで結果（PASS/FAIL）を確認できるようにする
  - [ ] 失敗時に「どの段で落ちたか」が分かるログ（正規化後テキスト、候補一覧、選定理由）を出せるようにする（debugフラグ）
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`（開発用テスト関数、フィクスチャ）
- 受け入れ基準（完了条件）：
  - フィクスチャがPASSし、FAIL時に原因が追える情報が出る。
- テスト/検証：
  - ブラウザconsoleで `runExtractionSelfTest()` を実行し、全ケースPASS。
- 依存関係・注意点：
  - 本番UIに影響しないよう、テスト関数は呼び出さない（必要ならURLクエリやフラグで有効化）。
- リスクと回避策：
  - リスク：フィクスチャが少なく、実機差に弱い
  - 回避策：Step 3-6/3-5 で集めた実データを随時フィクスチャに追加できる形にしておく

### Plan 2: Step 3-4 連携を見据えた失敗時の戻り方を整備
- 目的：抽出できない/自信がない時に、UIが自然に「手動入力」へ誘導できるようにする。
- 作業内容（チェックリスト）：
  - [ ] `errors[]` に機械可読なコード（例：`BP_PAIR_NOT_FOUND`、`PULSE_NOT_FOUND`、`VALIDATION_FAILED`）を入れる
  - [ ] `warnings[]` に `LOW_CONFIDENCE` や `MULTIPLE_CANDIDATES` を入れる
  - [ ] `confidence` のスケール（0-100）を固定し、UIの色分け閾値と合わせやすくする
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`
- 受け入れ基準（完了条件）：
  - UI側が `null` と `errors/warnings` を見て、「再試行」「手動入力」へ分岐できる材料が揃う。
- テスト/検証：
  - 抽出不能のフィクスチャで `errors` が入り、例外なく結果が返る。
- 依存関係・注意点：
  - Step 3-4 のUI要件（色分け閾値）に合わせ、閾値は定数化して後で調整しやすくする。
- リスクと回避策：
  - リスク：警告/エラーが多すぎて常に赤表示になる
  - 回避策：警告の条件は段階的に（まずは保守的に少なめ）導入し、実機で見て調整する

