```md
# ProjectRules.md

## 1. 目的とスコープ
- 目的：Phase 2「カメラ撮影機能」Step 2-2として、**撮影直後に画像をフルスクリーンでプレビューし**、ユーザーが **「再撮影」or「この画像を使う」** を選べる一連の体験を実装する。
- スコープ（やること）：
  - 撮影 → 画像処理（縮小/圧縮/向き補正） → プレビュー表示 →（再撮影｜採用）までのUI/状態遷移
  - 採用画像の**一時保存（Base64）**（次Step 2-4で利用できる形）
  - **メモリリーク対策**（ストリーム/巨大データ/イベントの後始末）
- 非スコープ（このStepではやらない）：
  - Step 2-4（入力画面への反映/UI連携の本実装）
  - サーバーアップロード、永続保存（IndexedDB等）、OCR処理
  - 端末別の完全なEXIF補正（ベストエフォート＋フォールバックのみ）

## 2. 技術スタック
- 使用言語：HTML / CSS / JavaScript（Vanilla, ES Modules）
- 使用Web API：MediaDevices(getUserMedia), Canvas, sessionStorage, (任意) ImageCapture, createImageBitmap
- 依存/前提：
  - Step 2-1でカメラアクセス＆撮影（video→canvasキャプチャ等）が実装済みであること
  - 対象は Android（PWA）中心。ブラウザ差分は最低限考慮
  - TODO: Step 2-1が **canvas方式のみ** か **ImageCapture併用** かを確認（向き補正の実装戦略が変わる）

## 3. ディレクトリ/ファイル方針
- 主要ファイル（想定）：
  - `index.html`：モーダル内のDOM（video領域/プレビュー領域/ボタン/ローディング）
  - `css/style.css`：モーダルのフルスクリーン、safe-area考慮、ボタン配置
  - `js/camera.js`：状態遷移、撮影→画像処理→プレビュー表示、再撮影/採用のハンドラ
  - （任意）`js/image-utils.js`：縮小/圧縮/回転など画像処理ユーティリティ（テストしやすさ目的）
  - （必要なら）`js/app.js`：採用完了の「フック」だけ（次Stepで本格利用）
- 読み込み順：HTML → CSS → JS（ES Modules）
- 定数/設定：
  - 画像処理の数値・保存キーなどは `js/constants.js`（または `camera.js` 冒頭の `const` ブロック）に集約し、魔法数を散在させない。

## 4. コーディング規約（横断）
- 命名：意図が伝わる語彙（略語乱用禁止）／JSは lowerCamelCase／CSSは BEM（`block__elem--mod`）またはUtilityのどちらかに統一
- コメント：原則日本語。関数の「入力/出力/副作用」を先頭1行で明記
- 構造：設定/定数・ドメインロジック・I/O（API/Storage）・UI更新を層分離
- 依存：グローバル共有を最小化。巨大なBase64やcanvas参照をグローバルに保持し続けない

### JavaScript（必須）
- ES Modulesで分割（`import/export`）。UI操作・状態・画像処理を分離
- ループ/タイミング：`setInterval`乱用禁止。必要なら `requestAnimationFrame` や差分時間で制御
- 例外処理：失敗時は「元画像でプレビュー」などフォールバックを用意し、UIが固まらないこと

### HTML/CSS（必須）
- HTML：セマンティック/landmark、`aria-*`付与、`aria-live`領域でエラー/処理中を通知
- CSS：ボタン等のタップ領域は 44–48px以上。Safe Area（`env(safe-area-inset-*)`）を考慮

## 5. 実装ルール（プロジェクト固有）

### 5.1 状態遷移（State Machine）
- 状態（最低限）：
  - `CAMERA_PREVIEW`：videoでカメラプレビュー表示
  - `PROCESSING`：撮影後の画像処理中（縮小/圧縮/向き補正）
  - `PHOTO_PREVIEW`：処理済み画像のプレビュー表示
- イベント：`CAPTURE` / `RETAKE` / `USE_PHOTO` / `CLOSE` / `ERROR`
- ガード：
  - `PROCESSING`中はボタンをdisabledにし、二重実行を状態でブロックする

### 5.2 撮影→プレビューの責務分割
- `capture()`：
  - 入力：Step 2-1のキャプチャ結果（canvas or blob）
  - 出力：一時画像（raw）
- `processCapturedImage(raw)`：
  - 入力：raw画像（canvas/bitmap/blob など）
  - 出力：最適化済み画像（推奨：`Blob` or `ImageBitmap`）＋メタ情報（幅/高さ/回転など）
- `showPhotoPreview(processed)`：
  - `<img>`に表示する場合：`URL.createObjectURL(blob)` を使い、破棄時に必ず `URL.revokeObjectURL`

### 5.3 画像縮小/圧縮（必須）
- 目的：表示/保存を軽くしつつ、将来のOCRに耐える視認性を残す
- デフォルト定数（初期値）：
  - `RESIZE_MAX_EDGE = 1280`（長辺目安）
  - `JPEG_QUALITY = 0.8`
  - `OUTPUT_MIME = 'image/jpeg'`（文字が潰れる等が出たら `image/png` を検討）
- 実装方針：
  - canvasでリサイズして `toBlob`（推奨）で出力（`toDataURL`はサイズ増＆メモリ負荷が高いので極力避ける）
  - 失敗時はフォールバックとして「元画像でプレビュー表示」を許可する

### 5.4 向き補正（ベストエフォート＋フォールバック必須）
- 自動補正（可能なら）：
  - `screen.orientation` / `window.orientation` 互換情報、または `track.getSettings()` の解像度から回転角を推定して描画時に補正
  - TODO: ImageCaptureを使えるなら `takePhoto()` のblob＋`createImageBitmap({ imageOrientation: 'from-image' })` を優先
- フォールバック（必須）：
  - プレビュー画面に「90°回転」ボタンを用意し、手動で修正できること
  - 回転操作は、**最終保存される画像（Base64）に反映**すること

### 5.5 一時保存（sessionStorage）
- 保存キー（固定）：`bp:lastCapturedImage`
- ペイロード最小要件（JSON文字列で保存）：
  - `base64`：最適化済み画像（DataURLまたはBase64本体）
  - `createdAt`：ISO文字列
  - `width` / `height`：最終画像サイズ
  - `mime`：`image/jpeg` 等
  - （任意）`rotation`：0/90/180/270
- 上書き/破棄ルール：
  - 1件のみ保持。新規採用時は上書き
  - 「再撮影」「キャンセル/閉じる」で、不要な一時データは破棄（UIも初期化）
- 保存失敗時：
  - 例：容量上限等で例外が起きた場合、ユーザーに通知し、画質（quality）を段階的に下げて再生成する（下げすぎはOCRに悪影響なので安全側）

### 5.6 クリーンアップ（メモリリーク対策）
- Object URL：`URL.createObjectURL` を使ったら必ず `URL.revokeObjectURL`（再撮影/閉じる/採用完了時）
- イベント：モーダル開閉でイベントリスナが重複登録されない構造にする（初期化は1回、解除/再利用を設計）
- カメラストリーム：
  - 採用完了/モーダル終了/エラー時は `stopCamera()` を呼び、track停止を統一
  - 再撮影時は、黒画面リスク回避のため **ストリーム維持** を基本（必要ならvideo再初期化）

## 6. UI/UX・入力操作の規約
- プレビュー画面：フルスクリーン（モーダル）。video表示領域と排他で切替
- ボタン：
  - 「再撮影」「この画像を使う」を主ボタンとして視認性高く配置（親指到達圏）
  - タップ領域 44–48px以上
  - `PROCESSING`中は disabled + ローディング表示
- ローディング：
  - `PROCESSING`中はスピナー/テキストを表示（`aria-busy="true"` 推奨）
- Safe Area：
  - 下部ボタンは `padding-bottom: env(safe-area-inset-bottom)` 等を考慮し、隠れないこと
- アクセシビリティ最低限：
  - モーダルオープン時にフォーカス移動、閉じる導線を提供
  - 主要ボタンに `aria-label`、通知は `aria-live` で読ませる

## 7. パフォーマンス/品質
- 画像処理：
  - 可能なら `toBlob` を使い非同期で処理（メインスレッド占有を減らす）
  - 大きい画像ほど処理時間が伸びるため、処理中UI（ローディング）を必ず出す
- データサイズ：
  - Base64は肥大化する前提で、**縮小/圧縮後のみ保存**する
  - 保存サイズが大きくなりすぎる場合のガードを実装する
- リソース：
  - 連続撮影（10〜20回）でも重くならないことを重視（URL破棄、巨大参照の解放）

## 8. テスト/デバッグ（DoD）
- 受け入れ（Done）条件：
  1. 撮影後にプレビュー画面が表示され、画像が崩れずに確認できる
  2. 「再撮影」でカメラプレビューへ戻れ、再度撮影できる（黒画面/フリーズしない）
  3. 「この画像を使う」で最適化済み画像が sessionStorage（`bp:lastCapturedImage`）に保存され、次Stepで利用できる
  4. 画像が長辺 1280px 目安に縮小され、端末で重くならない
  5. 画像向きが明らかにおかしいケースで、(a)自動補正 または (b)回転ボタン によりユーザーが詰まらない
  6. 連続「撮影→再撮影」を10回以上繰り返しても落ちない/著しく重くならない
- 手動テストシナリオ（最低限）：
  - 撮影→プレビュー→採用→（sessionStorageに残る）
  - 撮影→プレビュー→再撮影→再度撮影→採用
  - 端末縦/横で撮影し、向きが破綻しない or 回転で救える
  - 暗所/反射ありで撮影し、プレビューで数字が読める品質
  - 権限拒否/カメラ不可時に適切なエラー表示（Step 2-1方針に合わせる）

## 9. リリース/更新運用
- `todo.md`/計画mdの更新（数値・UI・保存形式・キー）を検知したら、必ず本Project Rulesへ差分反映する
- 変更時は「状態遷移」「保存ペイロード」「画像処理定数（1280/0.8等）」の3点を最優先で更新

## 10. 禁止事項/アンチパターン
- 指定なしでの外部FW導入（React/Vue等）
- `setInterval` での無制限ループ乱用（処理/描画は状態と非同期で制御）
- 魔法数の散在（縮小サイズ/画質/保存キー等は定数へ）
- Base64巨大文字列をグローバルに保持し続ける、Object URLをrevokeしない
- モーダル開閉のたびにイベントリスナを重複登録する

## 11. コミット/PR運用（任意）
- 1コミット=1意図（例：UI追加、画像処理追加、保存/後始末追加）
- メッセージは日本語で「要点→効果→影響範囲」
- PR/レビュー観点：
  - 連打・連続撮影時の安定性
  - sessionStorageの保存/破棄が仕様通り
  - URL.revokeObjectURL/イベント重複/ストリーム停止の後始末
```

```md
# 生成ログ（要約）
- 抽出した主要要件：撮影後フルスクリーンプレビュー、再撮影/採用、sessionStorageへBase64保存、長辺1280px縮小、向き補正（自動＋回転ボタン）、メモリリーク対策。
- 自動補完した既定値：`RESIZE_MAX_EDGE=1280`、`JPEG_QUALITY=0.8`、保存キー `bp:lastCapturedImage`、payloadに `createdAt/width/height/mime` を含める。
- 未確定点（TODO）：Step 2-1のキャプチャ方式（canvasのみかImageCapture併用か）により向き補正の最適手段が変わるため、確認後に自動補正実装を確定する。
- 安定性優先の方針：再撮影時はストリーム維持を基本にし、採用/閉じる/エラー時に停止して後始末を統一。
```

