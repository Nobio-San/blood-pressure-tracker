## 前提・要約
- 目的：血圧記録アプリをPWA（Progressive Web App）としてインストール可能にし、最低限のオフライン動作（アプリシェルの表示）を実現する。
- 成果物：`manifest.json` / `service-worker.js` / アイコン（192・512）/ `index.html`へのPWA設定（manifest参照・theme-color・SW登録・Apple向け設定）。
- 対象の種類（推定）：改修（既存WebアプリにPWA機能を追加）。
- 成功条件（Done）：
  - Chrome DevToolsでmanifestが正常認識され、Install可能（installability）
  - Android Chromeで「ホーム画面に追加」でき、起動時にstandalone表示
  - オフラインでも最低限（HTML/CSS/JS/主要アセット）が読み込め、画面が表示される
  - アイコンがホーム画面・スプラッシュ等で意図どおり表示される
- 前提（仮定した点があれば明記）：
  - アプリは静的ホスティングで配信され、HTTPS（またはlocalhost）でアクセス可能。
  - ルート配下（`/`）で配信される想定。サブディレクトリ配信の場合は `start_url` / `scope` / アセットパスを調整する。
  - 既存構成：`index.html`, `css/style.css`, `js/app.js`, 追加で `js/sheets-api.js` 等がある想定。
- 主要な制約：
  - Service Workerは登録スコープ配下しか制御できない（配置場所と `scope` が重要）。
  - キャッシュ更新・古いSWが残る問題が起きやすいため、バージョニングと更新フローを入れる。
- 既知の不明点（あれば）：
  - 配信環境（ドメイン直下か / サブパスか、例：GitHub Pagesなど）。
  - オフライン時にAPI連携（Google Apps Script）をどう扱うか（今回は「静的アセット中心」に限定）。

## 全体ステップ構成
- Step1: 配信パス・スコープの前提確定（後戻り防止）
- Step2: manifest.json作成（名前・色・start_url・icons）
- Step3: アイコン作成と配置（192/512 + Apple向け）
- Step4: index.htmlへPWA設定追加（manifest参照・meta・SW登録）
- Step5: service-worker.js実装（基本キャッシュ + オフラインフォールバック）
- Step6: キャッシュ更新/破棄の運用（バージョン更新・更新通知の最小実装）
- Step7: 動作検証（DevTools/Lighthouse/Android実機）

---

## Step1: 配信パス・スコープの前提確定（後戻り防止）
### Plan 1: 配信ルート（base path）とPWAスコープの決定
- 目的：`start_url` / `scope` / SW配置を誤ってインストール不可・キャッシュ対象漏れを起こさないようにする。
- 作業内容（チェックリスト）：
  - [ ] 配信URLの形を決める（例：`https://example.com/` か `https://example.com/blood-pressure-tracker/`）
  - [ ] SWの配置場所を決める（基本は配信ルート直下に `service-worker.js`）
  - [ ] `start_url` と `scope` の値の方針をメモに残す（README等に追記予定）
- 変更対象（想定ファイル/モジュール）：
  - README.md（追記）
- 受け入れ基準（完了条件）：
  - start_url/scope/ファイル配置の方針が文章で残り、以降のPlanで迷わない。
- テスト/検証：
  - Chrome DevToolsのApplicationタブでscopeが期待どおりになる見込みかを確認観点として整理。
- 依存関係・注意点：
  - GitHub Pages等サブパス配信なら `start_url` は `./` を基本にするなど調整が必要。
- リスクと回避策：
  - リスク：パス誤りでインストール不可／SWが効かない。
  - 回避策：最初に配信形を固定し、以降はその前提で実装する。

### Plan 2: オフライン時の最小UX要件を決める
- 目的：「最低限のオフライン動作」を具体化し、SW実装範囲をブレさせない。
- 作業内容（チェックリスト）：
  - [ ] オフライン時は「アプリ起動（UI表示）」を保証、API連携は失敗してもローカル保存で継続の方針
  - [ ] オフラインフォールバック（専用ページ or 既存indexの表示）を選択
  - [ ] キャッシュ対象の一覧方針（アプリシェル：HTML/CSS/JS + アイコン + ライブラリCDNは扱い注意）
- 変更対象（想定ファイル/モジュール）：
  - README.md（追記）
- 受け入れ基準（完了条件）：
  - 「オフライン時に何ができる/できない」が1段落で明文化されている。
- テスト/検証：
  - DevToolsでOfflineにしてもトップ画面が表示されることを検証項目として確定。
- 依存関係・注意点：
  - CDN依存（Chart.js等）がある場合、オフラインでは読み込めないためローカル配信に切り替えるか、オフライン時の機能制限を許容する必要がある。
- リスクと回避策：
  - リスク：CDNのままだとオフラインで白画面。
  - 回避策：PWA基本では「必須アセットのみ」キャッシュし、必要なら後続Stepでローカル化する。

---

## Step2: manifest.json作成（名前・色・start_url・icons）
### Plan 1: manifest.jsonの作成とプロパティ確定
- 目的：PWAとしてのメタ情報（名称、表示モード、テーマ色、起動URL、アイコン）を定義する。
- 作業内容（チェックリスト）：
  - [ ] `manifest.json` をプロジェクトルートに追加
  - [ ] `name` / `short_name` / `description` を文言確定
  - [ ] `display: standalone`, `orientation: portrait` を設定
  - [ ] `theme_color` / `background_color` をデザインと整合させる
  - [ ] `start_url` と（必要なら）`scope` をStep1の結論に合わせて設定
  - [ ] `icons` を `icons/icon-192.png`, `icons/icon-512.png` で参照する（パスに注意）
- 変更対象（想定ファイル/モジュール）：
  - manifest.json（新規）
- 受け入れ基準（完了条件）：
  - DevToolsでmanifestが読み込まれ、エラーが出ない。
  - start_urlが期待のURL（配信パス）になる。
- テスト/検証：
  - DevTools > Application > Manifestで内容を確認
- 依存関係・注意点：
  - ファイルがルート直下にない場合、`index.html`側のlinkパスと整合させる。
- リスクと回避策：
  - リスク：start_urlが誤りでインストール後の起動が404。
  - 回避策：サブパス配信なら `./` や明示パスで再確認。

### Plan 2: PWAメタデータ（カテゴリ等）の追加可否検討（軽量）
- 目的：将来のストア配布/見栄え改善に備え、追加が有効かを判断して必要最小限だけ入れる。
- 作業内容（チェックリスト）：
  - [ ] `categories` や `lang`（例：`ja`）を入れるか検討
  - [ ] `id`（PWA ID）を入れるか検討（将来の同一性に影響）
  - [ ] 入れる場合は最小限で追加し、READMEに理由を残す
- 変更対象（想定ファイル/モジュール）：
  - manifest.json
  - README.md
- 受け入れ基準（完了条件）：
  - 追加/非追加の判断が残り、manifestの意図が説明できる。
- テスト/検証：
  - DevToolsでmanifest警告が増えていないこと
- 依存関係・注意点：
  - ここで欲張ると仕様がブレるため「基本」に留める。
- リスクと回避策：
  - リスク：後でid変更が必要になる。
  - 回避策：現時点で固定する必要がなければ無理に入れない。

---

## Step3: アイコン作成と配置（192/512 + Apple向け）
### Plan 1: PWAアイコン（192/512）の作成・配置
- 目的：ホーム画面/アプリアイコンとして表示される画像を用意する。
- 作業内容（チェックリスト）：
  - [ ] `icons/` ディレクトリを作成
  - [ ] `icon-192.png` と `icon-512.png` を用意（透過可だが、見栄えのため背景込み推奨）
  - [ ] シンプルな「血圧計」モチーフで視認性の高いデザインにする
  - [ ] manifest.jsonのiconsパスと一致することを確認
- 変更対象（想定ファイル/モジュール）：
  - icons/icon-192.png（新規）
  - icons/icon-512.png（新規）
  - manifest.json（参照確認）
- 受け入れ基準（完了条件）：
  - DevToolsのManifestプレビューでアイコンが表示される。
- テスト/検証：
  - Androidでホーム画面追加後、アイコン表示を確認
- 依存関係・注意点：
  - PNGのサイズ・ファイル名・パスが一致しないとインストール条件を満たさない。
- リスクと回避策：
  - リスク：透過アイコンで背景に埋もれる。
  - 回避策：背景色を含む（theme_colorと相性の良い色）。

### Plan 2: Apple向けアイコン（apple-touch-icon）準備
- 目的：iOS（Safari）でのホーム画面追加時の見栄えを担保する。
- 作業内容（チェックリスト）：
  - [ ] `apple-touch-icon` 用のアイコンを用意（一般的に180x180）
  - [ ] `index.html` に `link rel="apple-touch-icon"` を追加する前提でパスを決める
- 変更対象（想定ファイル/モジュール）：
  - icons/apple-touch-icon.png（新規）
  - index.html（後続Stepで参照）
- 受け入れ基準（完了条件）：
  - iOSでホーム画面追加した際に想定アイコンが使われる（後続Step7で検証）。
- テスト/検証：
  - iOS Safariで追加して表示確認（可能なら）
- 依存関係・注意点：
  - iOSのPWA挙動はAndroid/Chromeと異なるため、最低限の対応に留める。
- リスクと回避策：
  - リスク：iOSでアイコンがぼやける。
  - 回避策：推奨サイズ（180）で用意する。

---

## Step4: index.htmlへPWA設定追加（manifest参照・meta・SW登録）
### Plan 1: index.htmlへmanifest / theme-color / アイコン設定を追加
- 目的：ブラウザがmanifestを読み込み、PWAのテーマ色やアイコンを認識できるようにする。
- 作業内容（チェックリスト）：
  - [ ] `<link rel="manifest" href="...">` を追加（パスは配信前提に合わせる）
  - [ ] `<meta name="theme-color" content="#2196F3">` を追加
  - [ ] `<link rel="apple-touch-icon" href="...">` を追加（Plan 3-2に合わせる）
  - [ ] （任意）`<meta name="apple-mobile-web-app-capable" content="yes">` 等の最小追加を検討
- 変更対象（想定ファイル/モジュール）：
  - index.html
- 受け入れ基準（完了条件）：
  - DevToolsでmanifestが読み込まれ、theme-colorが適用される（アドレスバー色など）。
- テスト/検証：
  - DevTools > Application > Manifest確認
  - モバイル表示でtheme-color反映を確認
- 依存関係・注意点：
  - パスは「相対/絶対」で挙動が変わるため、Step1の前提に従う。
- リスクと回避策：
  - リスク：サブパス配信で`/manifest.json`が404。
  - 回避策：`./manifest.json` 等に統一し、実際の配信URLで確認。

### Plan 2: Service Worker登録スクリプトを追加
- 目的：PWAのオフライン機能（キャッシュ）を有効化する。
- 作業内容（チェックリスト）：
  - [ ] `navigator.serviceWorker.register()` を `index.html` か `js/app.js` の初期化に追加
  - [ ] 登録成功/失敗時のログを最低限追加（デバッグ用）
  - [ ] 例外時にアプリ本体が壊れないようにtry/catch相当のガードを入れる
- 変更対象（想定ファイル/モジュール）：
  - index.html（または js/app.js）
- 受け入れ基準（完了条件）：
  - DevTools > Application > Service Workersで登録済みが確認できる。
- テスト/検証：
  - Hard reload / unregister後の再登録を確認
- 依存関係・注意点：
  - SWファイルはHTTPS/localhostでのみ有効。
- リスクと回避策：
  - リスク：登録スコープが狭く、必要なページ/ファイルが制御外。
  - 回避策：SWを配信ルート直下に置き、意図したscopeで登録。

---

## Step5: service-worker.js実装（基本キャッシュ + オフラインフォールバック）
### Plan 1: アプリシェルのプリキャッシュ実装
- 目的：オフラインでも「最低限の起動」ができるように、必要な静的リソースをキャッシュする。
- 作業内容（チェックリスト）：
  - [ ] `service-worker.js` を新規作成
  - [ ] キャッシュ名にバージョンを付与（例：`bp-cache-v1`）
  - [ ] installイベントでプリキャッシュ（`index.html`, `css/style.css`, `js/app.js`, `manifest.json`, icons 等）
  - [ ] activateイベントで古いキャッシュを削除
- 変更対象（想定ファイル/モジュール）：
  - service-worker.js（新規）
- 受け入れ基準（完了条件）：
  - 初回ロード後にOfflineへ切替えてもトップ画面が表示される。
  - 新バージョンに更新したら古いキャッシュが残り続けない。
- テスト/検証：
  - DevToolsでOfflineにして再読み込み
  - DevTools > Cache Storageでキャッシュ内容確認
- 依存関係・注意点：
  - プリキャッシュ対象に「実際に存在するパス」だけを入れる（1つでも404だとinstall失敗しやすい）。
- リスクと回避策：
  - リスク：キャッシュ対象のパスミスでSW installが失敗。
  - 回避策：プリキャッシュ一覧を最小から始め、段階的に増やす。

### Plan 2: fetchハンドラの基本戦略（Cache First中心）
- 目的：静的ファイルは高速・安定に配信し、ネットワーク不安定時も使えるようにする。
- 作業内容（チェックリスト）：
  - [ ] `fetch` でGETリクエストを対象にする（POST等は触らない）
  - [ ] 静的アセットはCache First（キャッシュ→なければネット→保存）
  - [ ] HTMLはNetwork Firstにするか、シンプルにプリキャッシュのみで賄うかを決定（Step1-2の方針に従う）
  - [ ] 失敗時にオフラインフォールバック（例：`index.html`）を返す
- 変更対象（想定ファイル/モジュール）：
  - service-worker.js
- 受け入れ基準（完了条件）：
  - 2回目以降のロードがキャッシュヒットし、オフラインでも表示できる。
- テスト/検証：
  - Network throttling / Offlineで挙動確認
- 依存関係・注意点：
  - Google Apps ScriptへのAPI通信はCORS/キャッシュ要件が異なるため「基本」ではキャッシュ対象外にするのが安全。
- リスクと回避策：
  - リスク：APIレスポンスをキャッシュしてしまい最新データが取れない。
  - 回避策：APIドメインはfetchハンドラで除外する（またはNetwork Only）。

### Plan 3: オフライン表示のユーザー通知（最小）
- 目的：オフライン時にユーザーが状況を理解できるようにする。
- 作業内容（チェックリスト）：
  - [ ] オフライン時に表示する簡易バナー/メッセージの方針を決める（今回は最小でOK）
  - [ ] `navigator.onLine` と `online/offline` イベントでUIを切替（実装は最小限）
- 変更対象（想定ファイル/モジュール）：
  - js/app.js（または共通UI）
  - css/style.css（必要なら）
- 受け入れ基準（完了条件）：
  - Offlineにすると「オフライン中」等の表示が出て、オンライン復帰で消える。
- テスト/検証：
  - DevToolsでOffline切替
- 依存関係・注意点：
  - オフライン時も入力/ローカル保存は可能、オンライン復帰時同期は本Stepではスコープ外。
- リスクと回避策：
  - リスク：通知が邪魔になる。
  - 回避策：小さく、常時表示にならないデザインにする。

---

## Step6: キャッシュ更新/破棄の運用（バージョン更新・更新通知の最小実装）
### Plan 1: SW更新時の挙動を安全側に寄せる（skipWaiting/clientsClaimの方針）
- 目的：更新が反映されない・逆に突然切り替わって壊れる、の両極を避ける。
- 作業内容（チェックリスト）：
  - [ ] `skipWaiting()` / `clientsClaim()` を使うか方針決定
  - [ ] 使う場合、更新が入った旨をUIで通知し「再読み込み」を促す最小導線を用意
  - [ ] 使わない場合、DevTools手順（更新テスト方法）をREADMEに残す
- 変更対象（想定ファイル/モジュール）：
  - service-worker.js
  - js/app.js（更新通知を入れる場合）
  - README.md
- 受け入れ基準（完了条件）：
  - 更新時の期待挙動（いつ新SWが有効化されるか）が説明でき、実際にテストできる。
- テスト/検証：
  - SWをv2に更新し、キャッシュ名が更新され、古いキャッシュが消えること
- 依存関係・注意点：
  - 「突然切り替え」はフォーム入力中のUXに影響しうるため、基本は“通知して再読み込み”が無難。
- リスクと回避策：
  - リスク：更新反映が遅く、バグが残り続ける。
  - 回避策：更新検知と再読み込み導線を入れる。

### Plan 2: キャッシュ対象の棚卸しと最小化
- 目的：キャッシュの肥大化や意図せぬ古い資産の温存を防ぐ。
- 作業内容（チェックリスト）：
  - [ ] プリキャッシュ一覧を確認し、必須アセットのみになっているか見直す
  - [ ] 画像やライブラリが増えたら追加手順をREADMEに記載
  - [ ] 可能ならビルドなしでも破壊的変更時にキャッシュバージョンを上げる運用を明文化
- 変更対象（想定ファイル/モジュール）：
  - service-worker.js
  - README.md
- 受け入れ基準（完了条件）：
  - 「何をキャッシュしているか」が一覧で分かり、増やす時のルールがある。
- テスト/検証：
  - Cache Storageの中身が想定の範囲に収まっていること
- 依存関係・注意点：
  - 画像を大量にキャッシュすると端末容量や更新コストに影響。
- リスクと回避策：
  - リスク：不要キャッシュで容量圧迫。
  - 回避策：基本はアプリシェルのみ、追加は都度検討。

---

## Step7: 動作検証（DevTools/Lighthouse/Android実機）
### Plan 1: Chrome DevToolsでPWA要件チェック
- 目的：インストール可能性・SW・キャッシュの状態を確実に確認する。
- 作業内容（チェックリスト）：
  - [ ] Application > Manifestで各項目（name, icons, start_url, display）が揃っている
  - [ ] Application > Service Workersで登録・scope・更新が確認できる
  - [ ] Application > Cache Storageでプリキャッシュが入っている
  - [ ] DevToolsのOfflineで再読み込みし、最低限表示できる
- 変更対象（想定ファイル/モジュール）：
  - なし（検証）
- 受け入れ基準（完了条件）：
  - DevTools上でPWA関連の致命的エラーがない。
- テスト/検証：
  - 上記チェックリストが全てOK
- 依存関係・注意点：
  - localhost以外はHTTPS必須。
- リスクと回避策：
  - リスク：DevTools上はOKでも実機で挙動差。
  - 回避策：必ずAndroid実機でPlan 2を実施。

### Plan 2: Android実機で「ホーム画面に追加」〜起動確認
- 目的：ユーザー体験としてPWAが成立しているかを最終確認する。
- 作業内容（チェックリスト）：
  - [ ] Android Chromeで対象URLを開く
  - [ ] 「ホーム画面に追加（インストール）」できる
  - [ ] 追加したアイコンから起動するとstandaloneで起動する
  - [ ] 端末を機内モード（または通信OFF）にしても起動できる
  - [ ] アイコンが意図どおり表示される
- 変更対象（想定ファイル/モジュール）：
  - なし（検証）
- 受け入れ基準（完了条件）：
  - インストール〜オフライン起動まで一連で成功。
- テスト/検証：
  - スクリーンショット等で結果を残す（任意）
- 依存関係・注意点：
  - 配信がHTTPだとインストール不可。
- リスクと回避策：
  - リスク：配信環境差（キャッシュ制御やMIME）。
  - 回避策：静的ホスティングの設定で正しいContent-Type（manifestは`application/manifest+json`推奨だが多くはjsonでも可）を確認。

### Plan 3: Lighthouse（PWA）監査で最後の穴埋め
- 目的：PWAとしてのベストプラクティスの不足を洗い出す。
- 作業内容（チェックリスト）：
  - [ ] LighthouseでPWAカテゴリを実行
  - [ ] 指摘（例：アイコン不足、start_url問題、SW fetch不足など）を解消
  - [ ] 重大指摘がなくなるまで最小の修正を反映
- 変更対象（想定ファイル/モジュール）：
  - manifest.json / service-worker.js / index.html（必要に応じて）
- 受け入れ基準（完了条件）：
  - LighthouseのPWA関連で「インストール不能」級の指摘が解消されている。
- テスト/検証：
  - Lighthouse再実行で改善を確認
- 依存関係・注意点：
  - スコア追いは目的化しない（最低限のインストール・オフラインが主目的）。
- リスクと回避策：
  - リスク：改善項目が増えてスコープ逸脱。
  - 回避策：今回は「基本」に必要な項目のみ対応し、残りはPhase4以降に回す。

