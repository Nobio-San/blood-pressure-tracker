## 前提・要約
- 目的：ローカルストレージに保存された血圧記録を、アプリ画面で「最新順・直近10件」を中心に一覧表示し、削除（確認付き）とメンバー絞り込み（任意）を提供する。
- 成果物：記録一覧UI（テーブル/カード）、一覧描画ロジック、削除機能、（任意）フィルタ機能、レスポンシブ対応、最低限の動作検証。
- 対象の種類（推定）：新規実装（Step 1-3 の保存機能に対して、Step 1-4 の一覧表示機能を追加）
- 成功条件（Done）：
  - ローカルストレージの記録が「最新が上」で表示される
  - 直近10件（設定で変更可能）だけ表示される
  - 削除ボタン→確認→削除後に一覧が即時更新される
  - スマホで視認・操作しやすい（横スクロール or カード）
  - （任意）メンバーで絞り込める
- 前提（仮定した点があれば明記）：
  - Step 1-1〜1-3 が完了しており、記録データは localStorage に配列で保存されている
  - 保存データは概ね以下の形（最低限 id, member, systolic, diastolic, pulse, datetime）
    - { id, member, systolic, diastolic, pulse, datetime(ISO文字列) }
  - 画面は index.html / css/style.css / js/app.js の素朴な構成（フレームワーク無し）
- 主要な制約：
  - PWA（モバイルファースト）、バニラJS、依存ライブラリは極力増やさない
  - 高齢者も使う可能性を考慮しタップ領域と可読性を優先
- 既知の不明点（あれば）：
  - localStorage のキー名（例: "bpRecords" など）
  - フォーマット表示で「血圧: XXX / YYY mmHg」を一覧のどこに出すか（カラム分割 vs まとめ表示）

## 全体ステップ構成
- Step1: 一覧UIの土台（HTML配置・空状態・基本スタイル）
- Step2: 一覧描画ロジック（ソート/件数制限/フォーマット）
- Step3: 操作機能（削除・確認・絞り込み・自動更新）
- Step4: レスポンシブ/UX仕上げとテスト

---

## Step1: 一覧UIの土台（HTML配置・空状態・基本スタイル）
### Plan 1: 要件の最終確認とデータ/キー整合チェック（スパイク）
- 目的：既存の保存形式・キー名・datetime形式を確認し、一覧実装の前提を固定する（後戻り防止）。
- 作業内容（チェックリスト）：
  - [ ] app.js の保存処理を読み、localStorage のキー名とデータ構造を確認
  - [ ] datetime が ISO 8601 で保存されているか確認（例: new Date().toISOString()）
  - [ ] ソート基準を「datetime降順」に決定（Date変換で比較）
  - [ ] 表示件数の定数（例: MAX_LIST_COUNT = 10）を追加する方針を決定
  - [ ] フィルタ機能の有無（任意）を「作る前提」で進め、UIは後で非表示可にする設計にする
- 変更対象（想定ファイル/モジュール）：
  - js/app.js（確認・必要なら軽微な調整）
- 受け入れ基準（完了条件）：
  - localStorage のキー名/データ構造/日時形式がメモとして残る（READMEでも可）
  - 一覧描画関数の入力（records配列）が定義できている
- テスト/検証：
  - 開発者ツールで localStorage の中身を確認し、1件以上のサンプルが存在する
- 依存関係・注意点：
  - Step 1-3 実装内容に依存
- リスクと回避策：
  - リスク：日時がローカル文字列保存でソートが壊れる
  - 回避策：保存時は ISO に統一／表示時のみフォーマット

### Plan 2: index.html に「記録一覧」セクションを追加（空状態含む）
- 目的：一覧表示の配置とDOMのアンカー（描画先）を作る。
- 作業内容（チェックリスト）：
  - [ ] 入力フォームの下（または別カード）に「記録一覧」セクションを追加
  - [ ] フィルタUI用の領域（メンバー選択、件数表示など）を用意（任意）
  - [ ] 一覧描画用のコンテナ（例: <div id="recordList"></div>）を設置
  - [ ] データが0件のときの空状態（例: 「まだ記録がありません」）を表示できる要素を用意
- 変更対象（想定ファイル/モジュール）：
  - index.html
- 受け入れ基準（完了条件）：
  - DOMに一覧の描画先が存在し、アプリ起動時に空状態が見える
- テスト/検証：
  - ブラウザ表示でセクションが崩れずに見える
- 依存関係・注意点：
  - 既存CSS構造と干渉しないクラス命名（例: .records-card など）
- リスクと回避策：
  - リスク：フォームと一覧が縦に長くなり操作性が悪化
  - 回避策：セクションをカード化し、折りたたみ（将来）を想定した構造にする

### Plan 3: 一覧の基本スタイル（テーブル + モバイル横スクロールの土台）
- 目的：テーブル表示がスマホでも破綻しない最低限のスタイルを整える。
- 作業内容（チェックリスト）：
  - [ ] テーブルの基本スタイル（余白、罫線、フォントサイズ、行間）
  - [ ] スマホで横スクロールできるラッパー（例: .table-scroll）を用意
  - [ ] ボタン（削除など）のタップ領域を44px以上目安で確保
  - [ ] 空状態メッセージのスタイル
- 変更対象（想定ファイル/モジュール）：
  - css/style.css
- 受け入れ基準（完了条件）：
  - スマホ幅でテーブルが見切れても横スクロールでき、文字が読める
- テスト/検証：
  - Chrome DevTools のモバイルエミュレーションで表示確認
- 依存関係・注意点：
  - カラム数が多いほど横スクロール前提になる（後続でカード化も検討）
- リスクと回避策：
  - リスク：横スクロールがユーザーに気づかれない
  - 回避策：影/グラデでスクロール可能を示す、またはStep4でカード切替を追加

---

## Step2: 一覧描画ロジック（ソート/件数制限/フォーマット）
### Plan 1: 描画ユーティリティ関数の実装（format / sort / limit）
- 目的：表示要件（日時フォーマット、単位表示、並び順、最大件数）を関数化して安定させる。
- 作業内容（チェックリスト）：
  - [ ] formatDateTime(datetimeIso) を実装（YYYY/MM/DD HH:MM）
  - [ ] formatBP(systolic, diastolic) を実装（"XXX / YYY mmHg" もしくは数値カラム）
  - [ ] formatPulse(pulse) を実装（"XXX bpm"）
  - [ ] sortRecordsDescByDatetime(records) を実装（Date変換で比較）
  - [ ] limitRecords(records, MAX_LIST_COUNT) を実装
- 変更対象（想定ファイル/モジュール）：
  - js/app.js
- 受け入れ基準（完了条件）：
  - これらの関数が単体で動作し、サンプル配列で期待どおりの出力になる
- テスト/検証：
  - console.log で入力/出力を確認（少なくとも3件で並び替え確認）
- 依存関係・注意点：
  - datetime の解析が端末依存にならないよう ISO前提で実装
- リスクと回避策：
  - リスク：datetime が空/不正で例外
  - 回避策：不正は末尾扱いにし、表示は "-" にするなどのフォールバック

### Plan 2: renderRecords() の実装（DOM描画・空状態・テンプレ）
- 目的：records配列からHTMLを生成し、一覧セクションへ描画できるようにする。
- 作業内容（チェックリスト）：
  - [ ] renderRecords(records, { memberFilter }) を実装
  - [ ] 0件時は空状態を表示、件数表示（例: "表示: 0件"）
  - [ ] テーブルのヘッダー（日時/メンバー/最高/最低/脈拍/削除）を出力
  - [ ] 各行に data-id を付与（削除の特定に使用）
  - [ ] XSS等を避けるため、可能なら textContent で組み立てる（最小でも入力値は数値想定）
- 変更対象（想定ファイル/モジュール）：
  - js/app.js
- 受け入れ基準（完了条件）：
  - recordsが1件以上あるとテーブルが描画され、0件だと空状態になる
- テスト/検証：
  - 1件/複数件/0件で表示が崩れない
- 依存関係・注意点：
  - Step1のDOMアンカー（#recordList など）に依存
- リスクと回避策：
  - リスク：DOM再描画のたびにイベントが増殖
  - 回避策：Step3でイベント委譲（containerに1回だけaddEventListener）

### Plan 3: 初期ロードと「記録追加後の再描画」接続
- 目的：アプリ起動時と新規記録保存後に一覧が必ず最新状態になるよう統合する。
- 作業内容（チェックリスト）：
  - [ ] DOMContentLoaded（または既存初期化処理）で loadRecords→renderRecords を呼ぶ
  - [ ] 既存の「記録する」処理の成功時に renderRecords を再実行
  - [ ] 保存・削除・フィルタ変更の共通で呼べる refreshRecordList() を用意
- 変更対象（想定ファイル/モジュール）：
  - js/app.js
- 受け入れ基準（完了条件）：
  - 保存直後に一覧の先頭へ新規記録が表示される
- テスト/検証：
  - 連続で2回保存しても、一覧が重複描画や崩れを起こさない
- 依存関係・注意点：
  - 既存の保存処理の戻り値/例外処理と整合を取る
- リスクと回避策：
  - リスク：保存は成功したが一覧更新が失敗し、ユーザーが不安になる
  - 回避策：更新失敗時も「保存済み」であることが分かるトースト/メッセージを残す

---

## Step3: 操作機能（削除・確認・絞り込み・自動更新）
### Plan 1: 削除機能（確認ダイアログ + localStorage更新 + 再描画）
- 目的：一覧から特定レコードを安全に削除できるようにする。
- 作業内容（チェックリスト）：
  - [ ] 各行に削除ボタン（ゴミ箱アイコン/テキスト）を配置
  - [ ] クリック時に confirm ダイアログを出す（例: "この記録を削除しますか？"）
  - [ ] OKの場合、idで対象を除外して localStorage を更新
  - [ ] refreshRecordList() で一覧を再描画
  - [ ] 削除後のフィードバック（例: "削除しました"）を表示
- 変更対象（想定ファイル/モジュール）：
  - js/app.js
  - index.html（必要なら削除ボタンのテンプレ）
  - css/style.css（削除ボタンの見た目）
- 受け入れ基準（完了条件）：
  - 削除→確認→一覧から消える（リロードしても復活しない）
  - キャンセル時は何も変わらない
- テスト/検証：
  - 先頭/末尾の削除、0件になった場合の空状態
- 依存関係・注意点：
  - idのユニーク性（Step 1-3 の採番方式）に依存
- リスクと回避策：
  - リスク：イベントリスナーが行ごとに大量につく
  - 回避策：一覧コンテナでのイベント委譲（e.target.closest）を採用

### Plan 2: （任意）メンバー絞り込みUIとロジック
- 目的：特定メンバーの記録だけを見られるようにし、家族利用の視認性を上げる。
- 作業内容（チェックリスト）：
  - [ ] 一覧セクションにフィルタ用 select を追加（"全員" + メンバー一覧）
  - [ ] 既存の入力フォームのメンバー一覧を流用できるなら共通化（定数/配列化）
  - [ ] 変更イベントで refreshRecordList() を呼び、memberFilter を適用
  - [ ] 表示件数（フィルタ後の件数）を表示
- 変更対象（想定ファイル/モジュール）：
  - index.html
  - js/app.js
  - css/style.css
- 受け入れ基準（完了条件）：
  - フィルタ変更で表示が切り替わり、リロードしても破綻しない
- テスト/検証：
  - メンバーA/Bが混在するデータで切り替え確認
- 依存関係・注意点：
  - メンバー名の表記揺れ（"母" vs "お母さん"）があると一致しない
- リスクと回避策：
  - リスク：表記揺れが生まれてフィルタが効かない
  - 回避策：メンバーは選択式のみにし、自由入力を許さない

### Plan 3: 状態管理の整理（単一ソース + 例外耐性）
- 目的：追加・削除・フィルタのたびに一貫して動くよう、recordsの扱いを整理する。
- 作業内容（チェックリスト）：
  - [ ] loadRecords() で必ず配列を返す（壊れたJSONは空配列にフォールバック）
  - [ ] saveRecords(records) を用意して更新を一箇所に集約
  - [ ] refreshRecordList() が load→filter→sort→limit→render を順に実行する
  - [ ] イベントリスナーは初期化時に1回だけ設定
- 変更対象（想定ファイル/モジュール）：
  - js/app.js
- 受け入れ基準（完了条件）：
  - 連続操作（追加→削除→フィルタ→追加）でも一覧が壊れない
- テスト/検証：
  - localStorageを手で壊した（不正JSON）ケースでもアプリが落ちず空状態になる
- 依存関係・注意点：
  - 既存の保存処理が records を二重に扱っている場合は軽微なリファクタが必要
- リスクと回避策：
  - リスク：既存処理への影響で回帰が出る
  - 回避策：保存/クリアの既存動作を手動で回帰確認するチェックリストを用意

---

## Step4: レスポンシブ/UX仕上げとテスト
### Plan 1: モバイル表示の最適化（テーブル横スクロール or カード切替）
- 目的：スマホでの視認性と操作性を上げる。
- 作業内容（チェックリスト）：
  - [ ] 画面幅が狭い場合は「カード形式」に切り替える（または横スクロール強調）
  - [ ] カード形式の場合：日時/メンバー/血圧/脈拍/削除を縦並びで見やすく
  - [ ] テーブル形式の場合：重要カラム（日時・血圧）を優先、削除はアイコン化
  - [ ] 行/カードの余白、フォントサイズ、コントラストを調整
- 変更対象（想定ファイル/モジュール）：
  - css/style.css
  - js/app.js（カードテンプレの追加が必要な場合）
- 受け入れ基準（完了条件）：
  - 360px幅程度でも情報が読み取れ、削除ボタンが押しやすい
- テスト/検証：
  - 代表的な幅（360/390/414px）で見え方を確認
- 依存関係・注意点：
  - 切替方式はCSSだけで対応できるか（DOM構造次第）
- リスクと回避策：
  - リスク：テーブル→カード切替が複雑になり工数増
  - 回避策：まず横スクロールで完了条件を満たし、カードは改善として段階導入

### Plan 2: UX/アクセシビリティ仕上げ（誤操作防止・可読性）
- 目的：家族利用（高齢者含む）でも扱いやすい最低限の品質を担保する。
- 作業内容（チェックリスト）：
  - [ ] 削除ボタンに aria-label（例: "記録を削除"）
  - [ ] キーボード操作（Tab移動）で削除ボタンがフォーカス可能
  - [ ] 重要なフィードバック（保存/削除）が視認できるメッセージ領域を統一
  - [ ] 空状態の導線（"入力して記録しましょう" など）
- 変更対象（想定ファイル/モジュール）：
  - index.html
  - css/style.css
  - js/app.js
- 受け入れ基準（完了条件）：
  - 誤削除しにくく、削除/保存の結果が分かる
- テスト/検証：
  - 文字サイズを大きくしてもレイアウトが破綻しない（ブラウザ拡大）
- 依存関係・注意点：
  - confirmダイアログはブラウザ依存だが最速で安全
- リスクと回避策：
  - リスク：confirmが味気ない/連打でストレス
  - 回避策：将来的にカスタムモーダルへ置き換え可能な構造に（関数化）

### Plan 3: 動作検証とデバッグ手順の整備（ミニ回帰）
- 目的：Step 1-4 の完了を確実にし、次のGoogle Sheets連携やグラフに進める状態にする。
- 作業内容（チェックリスト）：
  - [ ] 追加→一覧反映（最新が上、表示10件制限）
  - [ ] 11件以上入れて古いものが表示されないこと
  - [ ] 削除→確認→反映（キャンセル時は不変）
  - [ ] （任意）フィルタ→切替→追加/削除が破綻しない
  - [ ] localStorage を削除しても初期表示が落ちない
  - [ ] モバイル表示（横スクロール/カード）が使える
- 変更対象（想定ファイル/モジュール）：
  - （主に作業手順。必要なら微修正）
- 受け入れ基準（完了条件）：
  - 上記チェックがすべて通り、コンソールエラーが無い
- テスト/検証：
  - Chrome（Android想定）での簡易動作確認
- 依存関係・注意点：
  - 次工程（Google Sheets連携）でデータ件数が増える可能性があるため、描画の重さが出たらページング等を検討
- リスクと回避策：
  - リスク：表示件数制限が要件変更で増える
  - 回避策：MAX_LIST_COUNT を定数化し、将来の設定UI追加に備える

