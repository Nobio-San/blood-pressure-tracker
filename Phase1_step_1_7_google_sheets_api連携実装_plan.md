## 前提・要約
- 目的：PWA（血圧記録アプリ）から Google Apps Script（Webアプリ）経由で Google スプレッドシートへ **記録の保存（POST）** と **記録の取得（GET）** を行い、ローカルストレージと併用して耐障害性（オフライン時も記録可能）を確保する。
- 成果物：
  - `js/sheets-api.js`（新規）
  - `js/app.js`（連携呼び出し・エラーハンドリング追加）
  - `index.html`（`sheets-api.js` 読み込み追加）
  - （任意）`README.md`（設定手順追記）
- 対象の種類（推定）：新規機能追加（外部API連携）＋小規模な信頼性改善（オフライン/リトライ）
- 成功条件（Done）：
  - フォームから「記録する」で **ローカルストレージに保存され、オンライン時は Sheets にも保存**される
  - ネットワーク断や Apps Script エラー時でも **ローカル保存は成功し、ユーザーに適切な通知**が出る
  - （任意）`getFromSheets()` で **Sheets 側のデータが取得できる**（デバッグ/同期用途）
  - 開発者ツール（Network/Console）でエラーなく基本動作を確認できる
- 前提（仮定した点があれば明記）：
  - Apps Script は Step 1-6 の通り Webアプリとしてデプロイ済みで、URL（`SCRIPT_URL`）が取得できている
  - スプレッドシートの対象シート名は `血圧記録`、列は `ID / 日時 / メンバー / 最高血圧 / 最低血圧 / 脈拍` の順（ヘッダーあり）
  - クライアントは「まずローカル保存」を必須にし、Sheets 保存は「可能なら同期」扱いにする
- 主要な制約：
  - ブラウザからの直接 Sheets API 認証ではなく **Apps Script Webアプリ経由**（CORS/認証の簡略化）
  - Apps Script の実行時間/クォータに依存（大量アクセスは想定しない）
  - 「全員アクセス可」でデプロイすると第三者アクセスのリスクがある（必要なら簡易トークンで軽減）
- 既知の不明点（あれば）：
  - `SCRIPT_URL` をどこに配置するか（コード直書き、設定ファイル、環境変数相当など）
  - 取得（GET）したデータをアプリ側で同期表示に使うか（デバッグ用に留めるか）

## 全体ステップ構成
- Step1: 連携方針とI/F確定（前提確認・同期戦略）
- Step2: `sheets-api.js` 新規作成（POST/GET ラッパ実装）
- Step3: `index.html` へ読み込み導線を追加（依存関係の整理）
- Step4: `app.js` の保存フローに組み込み（ローカル優先＋Sheets送信）
- Step5: エラー/オフライン耐性の強化（UX、リトライ、重複対策）
- Step6: 動作確認とデバッグ（手動テスト手順整備）
- Step7: ドキュメント化と運用準備（URL設定、トラブルシュート）

---

## Step1: 連携方針とI/F確定（前提確認・同期戦略）
### Plan 1: Apps Script Webアプリの疎通確認（手動）
- 目的：クライアント実装前に、WebアプリURLが正しく動作していることを確認し、切り分けコストを下げる
- 作業内容（チェックリスト）：
  - [ ] WebアプリURL（`SCRIPT_URL`）を控える
  - [ ] ブラウザで `SCRIPT_URL` にアクセスして、`doGet` のJSONが返る/または期待した挙動になることを確認
  - [ ] 可能なら開発者ツールでレスポンスボディ/ステータスを確認
  - [ ] Apps Script の「実行」ログ（エディタの実行ログ/ログ出力）で呼び出しが入っていることを確認
- 変更対象（想定ファイル/モジュール）：
  - なし（GAS 側の確認作業）
- 受け入れ基準（完了条件）：
  - `GET` で期待する形式のJSONが返る（または最低限 200 で応答する）
- テスト/検証：
  - ブラウザアクセス、Apps Script 側ログ確認
- 依存関係・注意点：
  - Step 1-6 のデプロイ設定（アクセス権「全員」）に依存
- リスクと回避策：
  - リスク：`doGet` が巨大データになり重い → 回避：まずはヘッダー＋少量データで確認

### Plan 2: データI/F（送受信形式）を確定する
- 目的：フロントとGASの境界（JSON schema）を固め、後工程の手戻りを減らす
- 作業内容（チェックリスト）：
  - [ ] 送信JSONのキーを確定（例：`id, datetime, member, systolic, diastolic, pulse`）
  - [ ] `datetime` の形式を確定（ISO8601想定、表示は別途フォーマット）
  - [ ] レスポンス形式を確定（成功: `{status, message}` / 失敗: `{status, message, detail}` など）
  - [ ] 取得（GET）の戻り形式（配列 or オブジェクト）を決める（現状GASはヘッダーをキーにした配列）
- 変更対象（想定ファイル/モジュール）：
  - （任意）GAS（Step 1-6 のスクリプト）
  - `js/sheets-api.js`（設計に反映）
- 受け入れ基準（完了条件）：
  - I/Fがメモとして整理され、実装時に参照できる（README追記でも可）
- テスト/検証：
  - I/FがGAS実装と矛盾しないことを確認
- 依存関係・注意点：
  - GAS 側のヘッダー行（日本語）で `doGet` のキーが日本語になる点に注意
- リスクと回避策：
  - リスク：日本語ヘッダーがフロント側の扱いを難しくする → 回避：フロント側は `doGet` を「デバッグ用途」に留める/またはGAS側で英語キーに変換

---

## Step2: `sheets-api.js` 新規作成（POST/GET ラッパ実装）
### Plan 1: `sheets-api.js` の骨組みと設定方法を実装
- 目的：WebアプリURLやタイムアウト等の設定を一箇所に集約し、アプリ全体の見通しを良くする
- 作業内容（チェックリスト）：
  - [ ] `js/sheets-api.js` を新規作成
  - [ ] `API_URL`（= `SCRIPT_URL`）の定義方法を決める（定数/設定オブジェクト）
  - [ ] `fetch` 共通オプション（`headers`, `mode`, `cache`, `credentials` など）を整理
  - [ ] タイムアウト（AbortController）を導入するか判断（推奨）
  - [ ] エラー分類（ネットワーク/HTTPエラー/JSONパースエラー）方針を決める
- 変更対象（想定ファイル/モジュール）：
  - `js/sheets-api.js`
- 受け入れ基準（完了条件）：
  - `API_URL` を差し替えれば動く状態になっている
  - エラー時に例外が握り潰されず、呼び出し元で判断できる（return値 or throw のどちらかで統一）
- テスト/検証：
  - `API_URL` 未設定時に分かりやすいエラーメッセージが出る
- 依存関係・注意点：
  - ブラウザ環境（PWA）で動く実装にする（Node前提のコードは避ける）
- リスクと回避策：
  - リスク：URL直書きで漏洩/変更が面倒 → 回避：`README` に差し替え箇所を明記

### Plan 2: `saveToSheets(data)`（POST）の実装
- 目的：記録1件を Sheets に追記できるようにする
- 作業内容（チェックリスト）：
  - [ ] `saveToSheets(data)` を実装（`POST` で JSON を送る）
  - [ ] レスポンスの `status` を見て成功/失敗を判定
  - [ ] HTTPステータスが 200 でも `status !== success` の場合は失敗扱い
  - [ ] 失敗時は呼び出し側が扱いやすい形式で返す（例：`{ok:false, error}`）
  - [ ] エラー時に `console.error` を出す（開発中の切り分け用）
- 変更対象（想定ファイル/モジュール）：
  - `js/sheets-api.js`
- 受け入れ基準（完了条件）：
  - 正常系：Sheetsに新規行が追加される
  - 異常系：ネットワーク断などで失敗した場合に、呼び出し側へ失敗が伝播する
- テスト/検証：
  - DevTools NetworkでPOSTが送信されている
  - Apps Script側のログ/スプレッドシートで行追加を確認
- 依存関係・注意点：
  - `doPost` が `e.postData.contents` を前提にしている（JSON stringify 必須）
- リスクと回避策：
  - リスク：重複送信で同一IDが複数行になる → 回避：Step5で重複対策を入れる（推奨）

### Plan 3: `getFromSheets()`（GET）の実装
- 目的：Sheets上のデータを取得できるようにし、同期/デバッグの土台を作る
- 作業内容（チェックリスト）：
  - [ ] `getFromSheets()` を実装（`GET`）
  - [ ] JSONをパースし、配列として返す
  - [ ] 取得結果の形式が日本語キーになっている点を考慮し、必要なら変換関数を用意
  - [ ] 失敗時の扱いを `saveToSheets` と統一
- 変更対象（想定ファイル/モジュール）：
  - `js/sheets-api.js`
- 受け入れ基準（完了条件）：
  - ブラウザから呼ぶと JSON 配列が取得できる
- テスト/検証：
  - コンソールから関数呼び出し/NetworkでGET確認
- 依存関係・注意点：
  - データ量が増えると GET が重くなる可能性 → 必要ならGAS側で件数制限/期間フィルタを検討
- リスクと回避策：
  - リスク：将来データが増えて遅くなる → 回避：同期用途を限定し、必要になったらページング/期間指定を追加

---

## Step3: `index.html` へ読み込み導線を追加（依存関係の整理）
### Plan 1: スクリプト読み込み順の整理
- 目的：`app.js` から `saveToSheets/getFromSheets` が確実に参照できるようにする
- 作業内容（チェックリスト）：
  - [ ] `index.html` に `js/sheets-api.js` の読み込みを追加
  - [ ] 読み込み順を整理（`sheets-api.js` → `app.js`）
  - [ ] `defer`/`type=module` を採用するか決める（既存構成に合わせる）
- 変更対象（想定ファイル/モジュール）：
  - `index.html`
- 受け入れ基準（完了条件）：
  - ページ読み込み時に `saveToSheets/getFromSheets` が未定義にならない
- テスト/検証：
  - コンソールエラーが出ない（ReferenceErrorがない）
- 依存関係・注意点：
  - 既存の他JS（今後 `camera.js` `ocr.js` など）が増えることを見越し、読み込み方針を統一
- リスクと回避策：
  - リスク：読み込み順の崩壊 → 回避：`type=module` への移行を将来検討（今回無理にやらない）

---

## Step4: `app.js` の保存フローに組み込み（ローカル優先＋Sheets送信）
### Plan 1: 保存処理を「ローカル保存」→「Sheets送信」の2段階に分離
- 目的：ネットワーク状況に関係なく、入力データが失われない設計にする
- 作業内容（チェックリスト）：
  - [ ] 既存の「フォーム送信時」処理を確認し、保存ロジックを関数分割（例：`saveToLocal(record)`）
  - [ ] ローカル保存が成功した時点でユーザーに一次成功を伝える方針を決める（UI/メッセージ）
  - [ ] その後に `saveToSheets(record)` を呼び出す
  - [ ] Sheets送信が成功したら「同期完了」の追加メッセージを表示（トースト等）
- 変更対象（想定ファイル/モジュール）：
  - `js/app.js`
- 受け入れ基準（完了条件）：
  - オフラインでも保存操作が完了し、記録一覧に反映される
  - オンライン時は Sheets にも行が追加される
- テスト/検証：
  - オンライン/オフラインで保存フローを確認
- 依存関係・注意点：
  - ユーザー体験として「保存できたのか」が分かる表現にする
- リスクと回避策：
  - リスク：二段階でメッセージが多い → 回避：「ローカル保存完了（後で同期）」とまとめて表示する案も用意

### Plan 2: Sheets送信失敗時のUX（フォールバック）
- 目的：失敗しても不安を最小化し、再同期の導線を作る
- 作業内容（チェックリスト）：
  - [ ] `saveToSheets` が失敗した場合、UIで「ローカルに保存済み・同期失敗」を明示
  - [ ] 失敗時に記録を「未同期」として扱うか方針を決める（推奨：`synced: false` をローカルに保持）
  - [ ] （任意）「再同期」ボタン/メニューを追加する設計にする（実装はStep5で）
- 変更対象（想定ファイル/モジュール）：
  - `js/app.js`（データモデル、メッセージ表示）
- 受け入れ基準（完了条件）：
  - Sheets送信失敗時でもアプリが落ちない/操作継続できる
  - ユーザーが「データは消えていない」ことを理解できる
- テスト/検証：
  - DevToolsでOfflineにして保存→オンライン復帰後の挙動を確認
- 依存関係・注意点：
  - ローカルのデータ構造変更（`synced` 追加）をする場合、既存データのマイグレーションを考慮
- リスクと回避策：
  - リスク：既存localStorageの互換性崩れ → 回避：読み込み時にデフォルト値を補完

---

## Step5: エラー/オフライン耐性の強化（UX、リトライ、重複対策）
### Plan 1: 同期待ちキュー（未同期レコード）の基本設計を入れる（推奨）
- 目的：一時的な通信障害でも、後でまとめて同期できるようにする
- 作業内容（チェックリスト）：
  - [ ] ローカル保存データに `synced`（boolean）と `syncedAt`（任意）を追加する
  - [ ] Sheets送信成功時に `synced=true` に更新する
  - [ ] 同期失敗時は `synced=false` のまま保持し、件数をUIで軽く見せる（任意）
- 変更対象（想定ファイル/モジュール）：
  - `js/app.js`
- 受け入れ基準（完了条件）：
  - 未同期/同期済みがローカルで判別できる
- テスト/検証：
  - オフラインで2件保存→オンラインで同期成功に遷移できる
- 依存関係・注意点：
  - データ構造が将来のPhase（オフライン強化）にも使えるようにしておく
- リスクと回避策：
  - リスク：UIが複雑化 → 回避：まずは内部フラグのみ（画面表示は最小限）

### Plan 2: 再同期（手動リトライ）導線を追加（任意だが実用性高）
- 目的：ユーザーが自分で同期を回復できるようにする
- 作業内容（チェックリスト）：
  - [ ] 「未同期を再送」ボタンを追加（画面上部や設定メニュー）
  - [ ] `synced=false` のレコードを新しい順/古い順に再送する
  - [ ] 途中失敗したら停止し、進捗/結果を表示する
- 変更対象（想定ファイル/モジュール）：
  - `index.html`（ボタン追加）
  - `js/app.js`（再送処理）
- 受け入れ基準（完了条件）：
  - 未同期が0件になったことをユーザーが確認できる
- テスト/検証：
  - ネットワークを切った/戻した状態で再送が機能する
- 依存関係・注意点：
  - Apps Script の実行回数が増えるので、連続送信に簡単な間隔（数百ms）を入れる検討
- リスクと回避策：
  - リスク：大量件数で遅い → 回避：まずは想定件数（家族利用）を前提に簡易実装

### Plan 3: 重複対策（IDの冪等性）を検討・実装（推奨）
- 目的：リトライや二重送信で同じ記録が複数行になる事故を防ぐ
- 作業内容（チェックリスト）：
  - [ ] 方式を決める：
    - A) クライアント側で「送信済み」のみ送る（`synced`）
    - B) GAS側で `id` を検索して存在したら append しない（冪等化）
  - [ ] まずはAで十分か判断（家族利用ならAで現実的）
  - [ ] 可能ならBも実装（既存IDがある場合は success を返す）
- 変更対象（想定ファイル/モジュール）：
  - `js/app.js`（A）
  - （任意）GAS（B）
- 受け入れ基準（完了条件）：
  - 同じレコードを複数回送っても Sheets 側に重複行が増えにくい
- テスト/検証：
  - 同一IDを意図的に2回送って検証
- 依存関係・注意点：
  - GAS側で検索する場合、データ件数が増えると遅くなる可能性
- リスクと回避策：
  - リスク：Bの検索が重くなる → 回避：まずA、必要になったらB

### Plan 4: セキュリティ簡易強化（任意・推奨）
- 目的：「全員アクセス可」デプロイのリスクを軽減する
- 作業内容（チェックリスト）：
  - [ ] 共有シークレット（トークン）を1つ決める
  - [ ] クライアントのリクエストヘッダー or クエリにトークンを付与
  - [ ] GAS側でトークン検証し、NGなら 401/403 を返す
- 変更対象（想定ファイル/モジュール）：
  - `js/sheets-api.js`
  - GAS（Step 1-6 のスクリプト）
- 受け入れ基準（完了条件）：
  - トークンなしのリクエストが拒否される
- テスト/検証：
  - トークンあり/なしで挙動が変わることを確認
- 依存関係・注意点：
  - トークンはクライアントに入るため完全な秘匿はできない（最低限の防御）
- リスクと回避策：
  - リスク：設定が増える → 回避：READMEに設定箇所を1つに集約

---

## Step6: 動作確認とデバッグ（手動テスト手順整備）
### Plan 1: 手動テスト項目の作成と実施
- 目的：実装完了の判断をブレなく行う
- 作業内容（チェックリスト）：
  - [ ] 正常系：オンラインで1件保存→Sheetsに追記される
  - [ ] 異常系：Offlineで保存→ローカルに保存される（UIメッセージも適切）
  - [ ] 復帰系：オンライン復帰→（実装していれば）再同期でSheetsに反映
  - [ ] 取得：`getFromSheets()` でデータ取得できる（デバッグ確認）
  - [ ] ブラウザ更新後もローカルデータが残り、一覧が崩れない
- 変更対象（想定ファイル/モジュール）：
  - （任意）`README.md`（テスト手順）
- 受け入れ基準（完了条件）：
  - 上記テストがすべてパスし、致命的エラーがない
- テスト/検証：
  - Android Chrome を主に、PC Chromeでも確認
- 依存関係・注意点：
  - Apps Script 側の実行ログ/スプレッドシートを合わせて見ると切り分けが早い
- リスクと回避策：
  - リスク：原因切り分けが難しい → 回避：フロントに最低限のログ（成功/失敗理由）を残す

---

## Step7: ドキュメント化と運用準備（URL設定、トラブルシュート）
### Plan 1: 設定手順とトラブルシュートをREADMEに追記
- 目的：自分/家族運用で「URLどこに入れる？」や「動かない時どうする？」をすぐ解決できる
- 作業内容（チェックリスト）：
  - [ ] `SCRIPT_URL` の設定場所（`sheets-api.js` の定数）を明記
  - [ ] Apps Script のデプロイ設定（実行ユーザー/アクセス権）のメモ
  - [ ] よくある失敗：CORS、権限、URL間違い、JSON形式違い、シート名違い
  - [ ] DevToolsで見るべきポイント（Network/Console）
- 変更対象（想定ファイル/モジュール）：
  - `README.md`
- 受け入れ基準（完了条件）：
  - 初見でも設定/確認ができる手順が揃っている
- テスト/検証：
  - README手順に従って再現できる（別端末でも理想）
- 依存関係・注意点：
  - 将来、通知・オフライン強化などで設定が増えるため、READMEは「設定一覧」セクションを作るとよい
- リスクと回避策：
  - リスク：情報が散らばる → 回避：設定はできるだけ `sheets-api.js` に集約し、READMEは参照だけにする

