## 前提・要約
- 目的：血圧計の撮影画像に対して前処理（ROI切り抜き、グレースケール化、二値化、ノイズ除去など）を行い、Tesseract.js に渡す入力画像の品質を上げてOCR精度を向上させる。
- 成果物：
  - `preprocessImage(imageSource, options)`（画像要素/Blob/Base64などを受け取り、前処理済み `canvas` と付随メタを返す）
  - ROI切り抜き・グレースケール・二値化・ノイズ除去（必要に応じてモルフォロジー）を段階的に適用できる前処理パイプライン
  - デバッグ用の前処理結果プレビュー（開発用トグル）
- 対象の種類（推定）：新規実装（Phase 3 のOCR追加に伴う前処理機能の追加）
- 成功条件（Done）：
  - 前処理済み `canvas` をTesseract.jsへ渡せる
  - ROIがガイド枠と一致し、文字領域（数字表示部）にフォーカスできる
  - 二値化後の可読性が十分で、主要ケースでOCRの抽出成功率が体感で改善している（最低でも「前処理無し」より改善が見える）
  - 低スペックAndroidでもフリーズせず、前処理＋OCRの体験が許容範囲（目安：前処理が数百ms〜1.5s程度）
- 前提（仮定した点があれば明記）：
  - Step 3-1 により `js/ocr.js` 内でTesseractワーカーが初期化され、OCR呼び出し口がある
  - Phase 2 の撮影ガイド枠は「画面上の矩形」として定義でき、撮影画像座標系へ変換可能な情報（video/canvasサイズ等）が取れる
  - 画像の向き補正（EXIF等）は Step 2-2 側で概ね解消されている（未解消なら本Stepで最小限のフォローを入れる）
- 主要な制約：
  - PWA（ブラウザ）上でCanvasのみを用いた処理（ネイティブライブラリなし）
  - モバイル端末のメモリ/CPUに制約がある（ImageDataの多重生成を避ける）
- 既知の不明点（あれば）：
  - ガイド枠のROIを「固定比率」か「ユーザー調整」か（本Planでは固定比率＋今後拡張可能を想定）
  - 血圧計表示部のレイアウト（上段/下段/脈拍位置）が機種でどれくらい揺れるか（本Stepでは“全表示部”に寄せたROIを優先）

## 全体ステップ構成
- Step1: 前処理パイプライン設計とI/F確定（後工程の詰まりを防ぐ）
- Step2: ROI（切り抜き）実装（ガイド枠と画像座標の整合を最優先）
- Step3: グレースケール化・コントラスト調整（基礎品質を上げる）
- Step4: 二値化（Otsu / Adaptive）実装とパラメータ化（読みやすさ最重視）
- Step5: ノイズ除去・モルフォロジー（必要時の安定化）
- Step6: デバッグ可視化・計測・チューニング（改善を見える化して最適化）
- Step7: 結合確認（Tesseract連携）と回帰テスト素材整備（安定運用の足場）

---

## Step1: 前処理パイプライン設計とI/F確定
### Plan 1: 前処理I/Fとオプション設計
- 目的：後続の実装がブレないよう、入力形式・出力形式・オプションを先に確定する。
- 作業内容（チェックリスト）：
  - [ ] `preprocessImage(source, options)` の入力 `source` を定義（HTMLImageElement / HTMLCanvasElement / Blob / base64 のどれを採用するか）
  - [ ] 出力を定義（`{ canvas, meta }` 形式：metaにROI座標、処理時間、閾値など）
  - [ ] オプション設計（例：`roi`, `thresholdMode`, `contrast`, `medianRadius`, `debug`）
  - [ ] デフォルト値を決める（まず「動く・軽い」を優先）
  - [ ] エラー時の返り値/例外方針を決める（OCR側でリトライ判断できる情報を持たせる）
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`（前処理関数の追加、export設計）
  - （任意）`js/image-preprocess.js`（肥大化回避のために切り出し）
- 受け入れ基準（完了条件）：
  - 呼び出し側（OCR処理）から、前処理に渡す最小情報が明確になっている
  - optionsで各処理のON/OFFや方式切替ができる設計になっている
- テスト/検証：
  - ダミー画像を使い、前処理関数が `canvas` を返せることを確認
- 依存関係・注意点：
  - ROIの計算に必要な「ガイド枠座標」「撮影画像サイズ」の受け渡し方式を揃える
- リスクと回避策：
  - リスク：呼び出し側の都合でI/Fが後から変更になりがち
  - 回避策：まずは `ocr.js` 内の単一関数で完結 → 安定後に分割/最適化

### Plan 2: 処理段階の“直列パイプライン”実装の骨組み
- 目的：各処理（ROI/グレースケール/二値化/ノイズ除去）を差し替え可能にする。
- 作業内容（チェックリスト）：
  - [ ] `applyPipeline(canvas, steps, options)` のような内部関数を用意（steps配列で順序制御）
  - [ ] 各ステップが「入力canvas → 出力canvas（もしくは同一canvas更新）」で動くルールを統一
  - [ ] 計測（各ステップの処理時間）をmetaに積む
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`（または `js/image-preprocess.js`）
- 受け入れ基準（完了条件）：
  - まだ実処理が未完成でも、stepsを差し替えて動作確認できる骨組みがある
- テスト/検証：
  - 2〜3個のダミーステップで、順序通りに処理されることを確認
- 依存関係・注意点：
  - Canvasのサイズ変更は高コストなので、ROI以外はできるだけ同一サイズで処理
- リスクと回避策：
  - リスク：ステップ間でImageDataコピーが増えメモリを圧迫
  - 回避策：同一canvasに対するin-place更新を基本にし、必要時だけ別canvasを生成

---

## Step2: ROI（切り抜き）実装
### Plan 1: ガイド枠→撮影画像座標系への変換ロジック整理
- 目的：ガイド枠（画面座標）と実画像（キャプチャcanvas/画像）座標のズレを解消し、ROIを安定させる。
- 作業内容（チェックリスト）：
  - [ ] ガイド枠の定義情報を整理（表示領域DOMRect / video表示サイズ / 実キャプチャサイズ）
  - [ ] 画面座標→画像座標への変換式を定義（スケール、オフセット、アスペクト比、letterboxの有無）
  - [ ] 端末差（画面回転、devicePixelRatio）を考慮した計算にする
  - [ ] ROI座標のclamp（画像範囲外を切り捨て）
- 変更対象（想定ファイル/モジュール）：
  - `js/camera.js`（ガイド枠情報の取得/受け渡しが必要な場合）
  - `js/ocr.js`
- 受け入れ基準（完了条件）：
  - 任意の解像度でも「ガイド枠と切り抜き結果」が視覚的に一致する
- テスト/検証：
  - デバッグ表示で「ROI矩形を重ねて表示」し、ズレがないことを確認
- 依存関係・注意点：
  - Step 2-2 の画像向き補正が不完全だとROIがズレる
- リスクと回避策：
  - リスク：videoの表示サイズと実キャプチャcanvasサイズの取り違え
  - 回避策：撮影時点の「captureCanvas幅/高さ」と「videoの表示領域」を必ずログ/デバッグ表示

### Plan 2: ROI切り抜き関数の実装
- 目的：前処理対象を数字領域へ絞り、OCRの探索空間を減らして精度と速度を改善する。
- 作業内容（チェックリスト）：
  - [ ] `cropToROI(inputCanvas, roi)` を実装（drawImageで切り抜き）
  - [ ] ROIが未指定の場合のフォールバック（中央寄せ固定比率など）
  - [ ] ROIを少しだけ拡張するマージン設定（文字欠け防止）
  - [ ] metaへROI最終値を保存（デバッグに利用）
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`
- 受け入れ基準（完了条件）：
  - ROI指定あり/なし両方で、常に有効なcanvasが返る
  - 文字が欠けにくい（マージン込み）
- テスト/検証：
  - 複数の撮影画像でROIが適切かを目視確認
- 依存関係・注意点：
  - ROIで拡張しすぎると不要情報が増え二値化が不安定になる
- リスクと回避策：
  - リスク：端末ごとにガイド枠の見え方（aspect）が異なる
  - 回避策：ROIフォールバックを必ず用意し、まずは“全表示部”に寄せて安全側に倒す

---

## Step3: グレースケール化・コントラスト調整
### Plan 1: グレースケール変換の実装（軽量）
- 目的：色情報を削ぎ落として処理を単純化し、二値化の前提を整える。
- 作業内容（チェックリスト）：
  - [ ] `toGrayscale(canvas)` を実装（ImageDataのRGB→輝度）
  - [ ] 輝度計算方式を選定（例：0.299R+0.587G+0.114B）
  - [ ] alphaの扱いを明確化（基本は無視/255固定）
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`
- 受け入れ基準（完了条件）：
  - グレースケール化後の画像がデバッグ表示で白黒になっている
- テスト/検証：
  - 明暗差のある画像/反射のある画像で破綻しないか目視
- 依存関係・注意点：
  - ImageData処理はコストが高いので、ROI後に実施する（Step2→Step3順）
- リスクと回避策：
  - リスク：フル解像度で処理して重い
  - 回避策：ROI後に適度な縮小（長辺上限）を入れる余地をoptionsで用意

### Plan 2: コントラスト/明度補正の追加
- 目的：7セグや液晶文字のエッジを強調し、二値化の品質を上げる。
- 作業内容（チェックリスト）：
  - [ ] `adjustContrast(canvas, { contrast, brightness })` を実装（線形変換）
  - [ ] デフォルトは控えめ（過補正で文字が潰れないように）
  - [ ] optionsでON/OFF可能にする
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`
- 受け入れ基準（完了条件）：
  - 二値化前の段階で、数字が周囲より明確に分離して見えるケースが増える
- テスト/検証：
  - 暗い画像/白飛び画像での過補正の副作用を確認
- 依存関係・注意点：
  - 反射が強い場合は逆に悪化することがあるため、閾値方式と組み合わせ前提
- リスクと回避策：
  - リスク：端末カメラの色味差で最適値がブレる
  - 回避策：固定値ではなくoptions化＋デバッグで可視化し調整できるようにする

---

## Step4: 二値化（Otsu / Adaptive）実装とパラメータ化
### Plan 1: Otsu閾値（二値化）を実装
- 目的：照明条件が比較的一様なケースで、安定して文字を抽出する。
- 作業内容（チェックリスト）：
  - [ ] グレースケールのヒストグラム（0-255）を計算
  - [ ] Otsuで最適閾値を算出
  - [ ] `binarize(canvas, { threshold })` を実装（閾値をmetaに保存）
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`
- 受け入れ基準（完了条件）：
  - 一般的な撮影条件で、数字と背景が明確に二値化される
  - 閾値がmetaに記録され、デバッグで確認できる
- テスト/検証：
  - 明るい/暗い/中間の3パターンで二値化結果を比較
- 依存関係・注意点：
  - 反射や影が強い場合、全体閾値は弱い
- リスクと回避策：
  - リスク：Otsu計算が重い（ROIが大きいと特に）
  - 回避策：ROIを確実に効かせる／必要なら縮小を導入

### Plan 2: Adaptive Threshold（局所閾値）の実装（オプション/フォールバック）
- 目的：照明ムラや影、反射があるケースでも文字が残るようにする。
- 作業内容（チェックリスト）：
  - [ ] 方式を選択（例：近傍窓で平均/ガウシアン近似）
  - [ ] 窓サイズとC（減算値）をoptions化
  - [ ] `thresholdMode: 'otsu' | 'adaptive' | 'auto'` を用意
  - [ ] `auto` の場合、簡易ルール（コントラスト/ヒストグラム）で切替
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`
- 受け入れ基準（完了条件）：
  - 反射/影のある画像で、Otsuより読みやすい二値化結果が得られる
- テスト/検証：
  - 影が入った画像で、数字の欠けが減ることを目視確認
- 依存関係・注意点：
  - Adaptiveは計算量が大きいので、ROI縮小とセットで運用する
- リスクと回避策：
  - リスク：処理時間が増えUXが悪化
  - 回避策：`auto`ではまずOtsuを試し、失敗/低信頼時のみAdaptiveを試す方針にする（Step3-5で拡張可能）

---

## Step5: ノイズ除去・モルフォロジー
### Plan 1: メディアンフィルタ（軽量ノイズ除去）
- 目的：点ノイズやJPEGブロックの影響を減らし、誤認識を抑える。
- 作業内容（チェックリスト）：
  - [ ] 二値化前/後のどちらに適用するか決める（基本は二値化前のグレースケール段階）
  - [ ] `medianFilter(canvas, { radius })` を実装（radiusは小さく）
  - [ ] optionsでON/OFF、半径設定
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`
- 受け入れ基準（完了条件）：
  - ノイズが多い画像で、二値化後のゴミが減る
- テスト/検証：
  - ノイズの多い画像で前後比較（デバッグプレビュー）
- 依存関係・注意点：
  - 強すぎると文字の細部が消える（radiusを抑える）
- リスクと回避策：
  - リスク：計算量が増える
  - 回避策：デフォルトOFF、または低信頼時にのみON（将来）

### Plan 2: モルフォロジー（膨張/収縮）を“必要時のみ”追加
- 目的：文字の欠け（細い線）や穴埋めを補正して認識を安定化する。
- 作業内容（チェックリスト）：
  - [ ] 適用対象を二値化後に限定
  - [ ] `morphology(canvas, { op: 'dilate'|'erode', iterations })` を最小機能で実装
  - [ ] 既定はOFF、デバッグで効果が見えた場合のみ使う
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`
- 受け入れ基準（完了条件）：
  - 文字欠けが目に見えて改善するケースがある（ただし副作用が大きい場合はOFF維持）
- テスト/検証：
  - 文字が欠けた画像での効果確認
- 依存関係・注意点：
  - 膨張しすぎると数字が潰れて逆効果
- リスクと回避策：
  - リスク：調整沼化
  - 回避策：本Stepでは「実装＋デバッグで使える」まで、採用判断はStep3-5で行う前提

---

## Step6: デバッグ可視化・計測・チューニング
### Plan 1: 前処理結果のプレビュー（開発用トグル）
- 目的：前処理の改善を“見える化”し、ROI/閾値/補正の調整を容易にする。
- 作業内容（チェックリスト）：
  - [ ] `debug: true` のとき、前処理の各段階canvasを画面に表示できる仕組みを用意
  - [ ] 表示内容：元画像、ROI後、グレースケール後、二値化後（＋任意でノイズ除去後）
  - [ ] デバッグ情報：閾値、ROI座標、各ステップの処理時間
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`
  - （必要なら）`index.html`, `css/style.css`（デバッグ表示領域）
- 受け入れ基準（完了条件）：
  - スマホ実機で前処理の各段階を確認できる
- テスト/検証：
  - デバッグON/OFFで通常UIを壊さないこと
- 依存関係・注意点：
  - 画像を複数保持するとメモリを圧迫しやすい
- リスクと回避策：
  - リスク：デバッグ表示が本番に残る
  - 回避策：フラグで完全に隠す／開発環境判定（クエリパラメータ等）

### Plan 2: パラメータの初期チューニング方針を固める
- 目的：血圧計の典型ケースで「デフォルトがそこそこ当たる」状態にする。
- 作業内容（チェックリスト）：
  - [ ] 代表画像を5〜10枚集め、デフォルト設定で前処理結果を比較
  - [ ] まずはROIと二値化方式（Otsu/Adaptive）の当たりを決める
  - [ ] コントラスト/明度、Adaptiveの窓サイズなどを粗く調整
  - [ ] 変更ログ（どの画像にどう効いたか）をメモとして残す
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`（デフォルト値調整）
  - `README.md`（開発メモとして最小限）
- 受け入れ基準（完了条件）：
  - 「前処理無し」より二値化後の視認性が明らかに改善しているデフォルトになっている
- テスト/検証：
  - 代表画像で、前処理結果の比較（スクショ保存でも可）
- 依存関係・注意点：
  - 将来的にStep3-5で「複数パターン試行」へ拡張する前提
- リスクと回避策：
  - リスク：画像が少なく最適化が偏る
  - 回避策：家族の血圧計＋照明条件違いを混ぜる（暗所/反射/斜め）

---

## Step7: 結合確認（Tesseract連携）と回帰テスト素材整備
### Plan 1: OCR呼び出し口へ前処理を接続
- 目的：前処理済みcanvasを確実にTesseractへ渡し、効果測定できる状態にする。
- 作業内容（チェックリスト）：
  - [ ] OCR実行前に `preprocessImage` を呼ぶ（ROI→グレースケール→二値化→（必要なら）ノイズ除去）
  - [ ] Tesseractへ渡す形式（canvas/Blob）を統一
  - [ ] 失敗時フォールバック（前処理をスキップしてOCRする、もしくは別方式に切替）
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`
- 受け入れ基準（完了条件）：
  - 既存のOCRフローが壊れず、前処理ありで認識が走る
- テスト/検証：
  - 実機で撮影→前処理→OCRが通る（処理中にフリーズしない）
- 依存関係・注意点：
  - ここでは「抽出ロジック（Step3-3）」まで完了していなくても、rawTextの改善は確認できる
- リスクと回避策：
  - リスク：前処理に時間がかかりUXが悪化
  - 回避策：処理時間をmetaに記録し、重いステップはデフォルトOFF/低信頼時のみへ

### Plan 2: 回帰テスト用の画像セットと簡易チェック手順を用意
- 目的：今後（Step3-5最適化/Step3-3抽出）で前処理をいじっても壊れないようにする。
- 作業内容（チェックリスト）：
  - [ ] 代表画像を数枚（5〜10）プロジェクト外（手元/ドライブ等）に保存し、再現手順をREADMEに記録
  - [ ] アプリ側に「デバッグ画像を読み込む」導線（任意：ファイル入力）を用意できるなら追加
  - [ ] “前処理後の二値化結果が期待通りか”のチェック観点を明文化
- 変更対象（想定ファイル/モジュール）：
  - `README.md`
  - （任意）`index.html`, `js/app.js`（デバッグ用ファイル入力）
- 受け入れ基準（完了条件）：
  - 前処理の変更後も、代表画像で短時間に目視確認できる手順がある
- テスト/検証：
  - 代表画像を読み込み、前処理結果が再現できる
- 依存関係・注意点：
  - 個人情報（日時/個人名）が写る場合は保存方法に注意
- リスクと回避策：
  - リスク：サンプル画像が揃わず改善が定量化できない
  - 回避策：最低限「良い条件2枚」「悪い条件3枚」など偏りを避けて確保する

