# Blood Pressure Tracker

## 概要
血圧記録アプリ（Blood Pressure Tracker）は、日々の血圧を簡単に記録・管理できるWebアプリケーションです。

## 目的と機能
このアプリは以下の目的で開発されています：
- 血圧データの記録と管理
- 記録データの可視化
- 健康管理のサポート

### 現在の実装状況
- ✅ 基本的なファイル構造の構築
- ✅ HTML/CSS/JavaScriptの土台の準備
- ✅ レスポンシブデザインの基本設定
- ✅ 入力フォームUI作成
- ✅ ローカルストレージでのデータ保存
- ✅ 記録一覧表示機能
- ✅ Google Sheets API連携（クラウド同期）
- ✅ 基本グラフ表示機能（過去7日分の血圧推移）
- ✅ PWA対応（インストール可能・オフライン動作）
- ✅ カメラ撮影・画像プレビュー機能（Phase 2）
- ✅ OCR文字認識機能・画像前処理（Phase 3 Step 3-1〜3-3）
- ✅ OCR結果の自動入力・確認UI（Phase 3 Step 3-4）
- ✅ OCR精度の最適化・多重試行アーキテクチャ（Phase 3 Step 3-5）

## 使用技術
- **HTML5**: セマンティックなマークアップ
- **CSS3**: モバイルファーストのレスポンシブデザイン
- **JavaScript (ES6+)**: ブラウザネイティブのJavaScript
- **localStorage**: オフライン対応のローカルデータ保存
- **Google Apps Script**: スプレッドシート連携（Webアプリ経由）
- **Chart.js**: 血圧推移グラフの描画
- **PWA (Progressive Web App)**: オフライン動作・インストール機能

## セットアップ方法

### 必要な環境
- モダンなWebブラウザ（Chrome、Firefox、Safari、Edgeなど）

### 起動手順
1. このリポジトリをクローンまたはダウンロード
2. `index.html` をWebブラウザで開く
3. ブラウザのコンソール（開発者ツール）で初期化メッセージを確認

### 開発環境での確認
```bash
# シンプルなHTTPサーバーを起動する場合（オプション）
# Python 3の場合
python -m http.server 8000

# Node.jsのhttp-serverを使用する場合
npx http-server
```

ブラウザで `http://localhost:8000` にアクセス

## プロジェクト構造
```
blood-pressure-tracker/
├── index.html              # メインHTMLファイル
├── manifest.json           # PWAマニフェスト（アプリ情報・アイコン定義）
├── service-worker.js       # Service Worker（オフライン動作）
├── css/
│   └── style.css          # スタイルシート
├── js/
│   ├── app.js             # メインアプリケーションロジック
│   └── sheets-api.js      # Google Sheets API連携モジュール
├── icons/                  # PWAアイコン
│   ├── icon-192.png       # 192x192 アイコン
│   ├── icon-512.png       # 512x512 アイコン
│   └── apple-touch-icon.png # iOS用アイコン（180x180）
├── README.md              # プロジェクト説明（このファイル）
└── .gitignore             # Git除外設定
```

## Google Sheets 連携の設定

### 前提条件
1. Google アカウント
2. Google スプレッドシートの作成
3. Google Apps Script（GAS）の設定とデプロイ

### 設定手順

#### 1. スプレッドシートの準備
1. Google スプレッドシートを新規作成
2. シート名を「血圧記録」に変更
3. 1行目に以下のヘッダーを設定：
   ```
   ID | 日時 | メンバー | 最高血圧 | 最低血圧 | 脈拍
   ```

#### 2. Google Apps Script の設定
1. スプレッドシートで「拡張機能」→「Apps Script」を開く
2. 以下のコードを貼り付け：

```javascript
// doPost: データを受信してシートに追記
function doPost(e) {
  try {
    const data = JSON.parse(e.postData.contents);
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('血圧記録');
    
    if (!sheet) {
      return ContentService.createTextOutput(JSON.stringify({
        status: 'error',
        message: 'シート「血圧記録」が見つかりません'
      })).setMimeType(ContentService.MimeType.JSON);
    }
    
    // 重複チェック（任意）
    const existingData = sheet.getDataRange().getValues();
    for (let i = 1; i < existingData.length; i++) {
      if (existingData[i][0] === data.id) {
        return ContentService.createTextOutput(JSON.stringify({
          status: 'success',
          message: '既に登録済みです'
        })).setMimeType(ContentService.MimeType.JSON);
      }
    }
    
    // データを追記
    sheet.appendRow([
      data.id,
      data.datetime,
      data.member,
      data.systolic,
      data.diastolic,
      data.pulse
    ]);
    
    return ContentService.createTextOutput(JSON.stringify({
      status: 'success',
      message: 'データを保存しました'
    })).setMimeType(ContentService.MimeType.JSON);
    
  } catch (error) {
    return ContentService.createTextOutput(JSON.stringify({
      status: 'error',
      message: 'エラーが発生しました',
      detail: error.toString()
    })).setMimeType(ContentService.MimeType.JSON);
  }
}

// doGet: データを取得
function doGet(e) {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('血圧記録');
    
    if (!sheet) {
      return ContentService.createTextOutput(JSON.stringify([]))
        .setMimeType(ContentService.MimeType.JSON);
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const rows = data.slice(1);
    
    const result = rows.map(row => {
      const obj = {};
      headers.forEach((header, index) => {
        obj[header] = row[index];
      });
      return obj;
    });
    
    return ContentService.createTextOutput(JSON.stringify(result))
      .setMimeType(ContentService.MimeType.JSON);
      
  } catch (error) {
    return ContentService.createTextOutput(JSON.stringify([]))
      .setMimeType(ContentService.MimeType.JSON);
  }
}
```

3. 「デプロイ」→「新しいデプロイ」を選択
4. 種類：「ウェブアプリ」を選択
5. 設定：
   - 説明: 任意（例：血圧記録API）
   - 次のユーザーとして実行: **自分**
   - アクセスできるユーザー: **全員**（注：家族内共有の場合）
6. 「デプロイ」をクリック
7. **WebアプリのURL** をコピー（例：`https://script.google.com/macros/s/...../exec`）

#### 3. アプリ側の設定
1. `js/sheets-api.js` を開く
2. 冒頭の `SCRIPT_URL` に、コピーしたWebアプリのURLを設定：

```javascript
const SCRIPT_URL = 'https://script.google.com/macros/s/YOUR_SCRIPT_ID/exec';
```

3. ファイルを保存

### 動作確認
1. アプリを開いて血圧を記録
2. 「ローカルに保存し、クラウドに同期しました」と表示されることを確認
3. Google スプレッドシートに1行追加されていることを確認
4. オフライン状態で記録し、「未同期を再送」ボタンが表示されることを確認
5. オンライン復帰後に「未同期を再送」ボタンをクリックし、同期されることを確認

## トラブルシュート

### 同期が失敗する場合

#### 1. ネットワークエラー
- **症状**: 「ネットワークエラー：オンライン状態を確認してください」
- **対処**: 
  - インターネット接続を確認
  - ブラウザがオフラインモードになっていないか確認
  - ローカルには保存されているため、後で「未同期を再送」で同期可能

#### 2. URLが未設定
- **症状**: 「SCRIPT_URL が設定されていません」
- **対処**: 
  - `js/sheets-api.js` の `SCRIPT_URL` を確認
  - Google Apps Script のWebアプリURLが正しく設定されているか確認

#### 3. CORS エラー
- **症状**: ブラウザコンソールに「CORS policy」エラー
- **対処**: 
  - Google Apps Script のデプロイ設定を確認
  - 「アクセスできるユーザー」が「全員」になっているか確認
  - 古いデプロイを削除し、新しくデプロイし直す

#### 4. HTTPエラー（401/403）
- **症状**: 「HTTP エラー: 401」または「403」
- **対処**: 
  - Google Apps Script の「次のユーザーとして実行」が「自分」になっているか確認
  - スプレッドシートへのアクセス権限を確認

#### 5. シートが見つからない
- **症状**: 「シート『血圧記録』が見つかりません」
- **対処**: 
  - スプレッドシートのシート名が「血圧記録」になっているか確認（全角）
  - シート名のタブをダブルクリックして確認

#### 6. データ形式エラー
- **症状**: 「サーバーからの応答が不正です」
- **対処**: 
  - Google Apps Script のコードが正しく保存されているか確認
  - GAS エディタの「実行ログ」でエラー内容を確認
  - ヘッダー行のスペルミスがないか確認

### デバッグ方法
1. **ブラウザの開発者ツール**を開く（F12キー）
2. **Console** タブでエラーメッセージを確認
3. **Network** タブで以下を確認：
   - リクエストが送信されているか
   - ステータスコード（200が正常）
   - レスポンスの内容
4. **Google Apps Script** 側：
   - GASエディタの「実行」→「実行ログを表示」でサーバー側のログを確認

## PWA（Progressive Web App）機能

### PWAとは
このアプリはPWA（Progressive Web App）として実装されており、以下の機能が利用できます：
- **インストール可能**: スマートフォンやPCのホーム画面に追加して、ネイティブアプリのように使用できます
- **オフライン動作**: インターネット接続がなくても、アプリの起動・データの閲覧・新規入力が可能です
- **高速起動**: キャッシュされたリソースにより、起動が高速になります

### インストール方法

#### Android（Chrome）
1. Chrome で本アプリを開く
2. アドレスバー右上のメニュー（⋮）→「ホーム画面に追加」または「アプリをインストール」を選択
3. ホーム画面にアイコンが追加されます
4. アイコンをタップすると、スタンドアロンモード（ブラウザのUIなし）で起動します

#### iOS（Safari）
1. Safari で本アプリを開く
2. 画面下部の「共有」ボタン（□↑）をタップ
3. 「ホーム画面に追加」を選択
4. 「追加」をタップ
5. ホーム画面にアイコンが追加されます

#### PC（Chrome/Edge）
1. Chrome または Edge で本アプリを開く
2. アドレスバー右側の「インストール」アイコン（⊕）をクリック
3. 「インストール」をクリック
4. デスクトップアプリとして起動できます

### オフライン機能

#### 利用可能な機能
- アプリの起動と表示
- 新規データの入力・保存（ローカルストレージ）
- 過去の記録の閲覧
- グラフ表示（ローカルデータ）
- データの削除

#### 制限される機能
- Google Sheets への同期（インターネット接続が必要）
- Chart.js の初回読み込み（CDN依存のため）

#### オフライン時の挙動
1. オフライン時に新規データを入力すると、ローカルストレージに保存されます
2. 画面上部に「⚠️ オフラインモード」のバナーが表示されます
3. Google Sheets への同期は失敗しますが、「未同期」として記録されます
4. インターネット接続が回復したら、「未同期を再送」ボタンから手動で同期できます

### PWA技術仕様（開発者向け）

#### 配信パスとスコープ
- **配信形式**: ドメイン直下またはサブパス配信の両方に対応
- **start_url**: `./` （相対パス）
- **scope**: `./` （Service Workerの制御範囲）
- **Service Worker配置**: プロジェクトルート直下（`service-worker.js`）

#### キャッシュ戦略
- **キャッシュ名**: `bp-cache-v1` （バージョン管理用）
- **プリキャッシュ対象**:
  - `index.html`
  - `css/style.css`
  - `js/app.js`
  - `js/sheets-api.js`
  - `manifest.json`
  - アイコン（192/512/apple-touch-icon）

- **キャッシュ戦略**:
  - 静的アセット（HTML/CSS/JS/画像）: **Cache First**（キャッシュ→ネットワーク→保存）
  - CDN（Chart.js）: **Network First**（ネットワーク→キャッシュフォールバック）
  - 外部API（Google Apps Script）: **Network Only**（キャッシュ対象外）

#### Service Worker更新手順
1. `service-worker.js` を編集
2. キャッシュ名のバージョンを上げる（例：`v1` → `v2`）
   ```javascript
   const CACHE_VERSION = 'v2';
   ```
3. ファイルを保存してデプロイ
4. ユーザーがアプリを再読み込みすると、新しいService Workerが登録されます
5. 既存のブラウザタブを閉じて再度開くと、新しいバージョンが有効化されます

#### DevToolsでの確認方法
1. Chrome DevTools を開く（F12）
2. **Application** タブを選択
3. 以下を確認：
   - **Manifest**: エラーがないか、アイコンが表示されるか
   - **Service Workers**: 登録済みか、scopeが正しいか
   - **Cache Storage**: `bp-cache-v1` にファイルが格納されているか
4. **Network** タブで「Offline」にチェックを入れて、オフライン動作を確認

#### 開発時の注意点
- **HTTPS必須**: Service Workerは `localhost` または HTTPS でのみ動作します
- **キャッシュ更新**: 開発時にキャッシュが残る場合は、DevTools > Application > Storage > "Clear site data" で削除
- **Hard Reload**: Ctrl+Shift+R（Mac: Cmd+Shift+R）でキャッシュを無視した再読み込みが可能
- **Unregister**: DevTools > Application > Service Workers > "Unregister" で登録解除できます

## セキュリティについて

### 注意事項
- Google Apps Script を「全員アクセス可」でデプロイすると、URLを知っている人は誰でもアクセス可能になります
- 家族内での利用を想定した簡易的な実装です
- 機密性の高いデータの場合は、OAuth認証などより強固な認証方式の導入を検討してください

### 簡易的な対策（任意）
`js/sheets-api.js` と Google Apps Script の両方でトークン認証を実装することで、最低限の防御が可能です。詳細は計画書を参照してください。

## 今後の開発予定
- ✅ カメラ撮影機能（Phase 2 完了）
- ✅ OCR自動入力機能（Phase 3 Step 3-4 完了）
- OCR精度のさらなる最適化（言語データのローカル配置・PSM調整）
- データ分析機能（統計情報、異常値検知など）
- 通知機能（測定時刻リマインダー）
- PWA高度化（バックグラウンド同期、プッシュ通知など）

## Phase 3: OCR機能（Tesseract.js）

### 概要
血圧計の画面を撮影した画像から、数値を自動的に読み取るOCR（光学文字認識）機能を導入しました。

### 技術仕様
- **OCRエンジン**: Tesseract.js v5.0.3（CDN経由）
- **認識言語**: 日本語 + 英語（`jpn+eng`）
- **認識対象文字**: 数字とスラッシュ（`0123456789/`）
- **PSM（Page Segmentation Mode）**: 6（一様なテキストブロック）

### ファイル構成
- `js/ocr.js` - OCRモジュール（Tesseract.js wrapper）
  - `window.OCR.initOcr()` - ワーカー初期化
  - `window.OCR.recognizeText(image, options)` - OCR実行（前処理あり）
  - `window.OCR.terminateOcr()` - ワーカー破棄
  - `window.OCR.preprocessImage` - 画像前処理（ROI/グレースケール/二値化）
- `js/image-preprocess.js` - 画像前処理モジュール（Phase 3 Step 3-2）
- `js/constants.js` - 前処理デフォルト値（ROIマージン、閾値方式など）

### 使用方法

#### 基本的な使い方
```javascript
// 1. 初期化（自動実行されるため、通常は不要）
await window.OCR.initOcr();

// 2. OCR実行
const result = await window.OCR.recognizeText(imageBase64);
console.log('認識テキスト:', result.rawText);
console.log('信頼度:', result.confidence);

// 3. 終了（メモリ解放）
await window.OCR.terminateOcr();
```

#### 進捗表示付きでOCRを実行
```javascript
const result = await window.OCR.recognizeText(imageBase64, {
    onProgress: (info) => {
        console.log(`${info.status}: ${Math.round(info.progress * 100)}%`);
    }
});
```

### 疎通テスト手順

#### 1. デバッグモードの有効化
アプリのURLに `?debug=1` パラメータを追加してアクセス：
```
http://localhost:8000/?debug=1
```

#### 2. OCRテストボタンの表示
デバッグモードでは「🔍 OCRテスト」ボタンが表示されます。

#### 3. テスト実行
- **画像がある場合**: 撮影済みの画像に対してOCRを実行
- **画像がない場合**: サンプル画像（`120 / 80` と `75`）を自動生成してOCRを実行

#### 4. 結果確認
- アラートで認識結果が表示されます
- コンソールに詳細ログが出力されます
- **前処理デバッグ**（`?debug=1` 時）: 画面下部に前処理の各段階（ROI後・グレースケール・二値化）のプレビューと、閾値・処理時間が表示されます

### 画像前処理（Phase 3 Step 3-2）

OCR精度向上のため、認識前に以下の前処理を適用します（失敗時は前処理をスキップして継続）。
1. **ROI切り抜き** - ガイド枠に合わせた領域、未指定時は中央固定比率
2. **長辺縮小** - 端末負荷軽減（デフォルト長辺 960px）
3. **グレースケール** - 輝度変換
4. **二値化** - Otsu 閾値（または Adaptive / auto）
5. （任意）メディアンフィルタ・モルフォロジー

**回帰確認の足場**: 代表画像を 5〜10 枚（良条件 2 枚以上・悪条件 3 枚以上）手元に用意し、`?debug=1` で「OCRテスト」実行後に前処理プレビューと認識結果を目視確認する手順を推奨します。個人情報が写る画像は保存先・共有範囲に注意してください。

### トラブルシュート

#### 初回ロードが遅い
- **症状**: OCR初回実行時に時間がかかる
- **原因**: 言語データ（`jpn.traineddata` / `eng.traineddata`）のダウンロード
- **対処**: 
  - 初回のみ数秒〜十数秒かかります（通信速度に依存）
  - 2回目以降はブラウザキャッシュが使用され、高速化されます

#### CORS エラー
- **症状**: コンソールに「CORS policy」エラー
- **対処**: 
  - Tesseract.js はCDN（jsDelivr）から配信されているため、通常は発生しません
  - ローカルファイルで開いている場合は、HTTPサーバー経由でアクセスしてください

#### ワーカーが初期化できない
- **症状**: 「OCRワーカーの初期化に失敗しました」エラー
- **対処**: 
  - ブラウザのコンソールで詳細なエラーメッセージを確認
  - ネットワーク接続を確認
  - ブラウザキャッシュをクリアして再試行

#### 認識精度が低い
- **原因**: 
  - 画像の解像度が低い
  - 文字が小さい、または不鮮明
  - 照明条件が悪い
- **対処**: 
  - 撮影時に血圧計の画面をできるだけ大きく撮影
  - 十分な明るさで撮影
  - 画像前処理（ROI・グレースケール・二値化）は自動適用されています。`?debug=1` で前処理プレビューを確認してチューニング可能

### 技術的な詳細

#### ワーカーのシングルトン管理
OCRワーカーは重い処理のため、シングルトンとして管理されます：
- 初回 `recognizeText()` 呼び出し時に自動的に初期化
- 2回目以降は既存のワーカーを再利用
- 多重初期化は防止されます

#### メモリ管理
長時間使用時のメモリリーク対策：
- `terminateOcr()` でワーカーを破棄できます
- ページリロード時、ワーカーは自動的に破棄されます
- 今後、一定時間アイドル後の自動破棄も検討

#### 設定のカスタマイズ
`js/ocr.js` の `CONFIG` オブジェクトで設定を変更できます：
```javascript
const CONFIG = {
    lang: 'jpn+eng',                              // 認識言語
    langPath: 'https://cdn.jsdelivr.net/...',    // 言語データ配置先
    tesseractConfig: {
        tessedit_char_whitelist: '0123456789/',  // 認識対象文字
        psm: 6                                    // ページ分割モード
    }
};
```

---

### OCR結果の自動入力と確認UI（Phase 3 Step 3-4）

#### 機能概要
血圧計の写真を撮影し「この画像を使う」を押すと、OCRが自動で文字を読み取り、入力フォームへ数値を自動入力します。  
認識結果の信頼度（精度）が色とアイコンで表示され、内容を確認・修正してから記録できます。

| 信頼度 | バッジ表示 | 意味 |
|---|---|---|
| 90%超 | 🟢 `✓ XX%` | 認識精度が高い（そのまま記録を推奨） |
| 70〜90% | 🟡 `! XX%` | やや不確か（目視で確認してください） |
| 70%未満 | 🔴 `✕ XX%` | 精度が低い（手動で確認・修正してください） |

---

#### 動作確認手順（初心者向け）

以下の手順を1つずつ試してください。各ステップで何が起きるかを合わせて説明します。

---

##### ステップ1：アプリをHTTPS経由で開く

カメラ機能はHTTPS（またはlocalhost）でしか動作しません。以下のいずれかで起動してください。

```bash
# 方法A: 付属の簡易HTTPSサーバーを使う（おすすめ）
python https_server.py
# → https://localhost:4443 でアクセス

# 方法B: Pythonの標準HTTPサーバーを使う（localhostのみ可）
python -m http.server 8000
# → http://localhost:8000 でアクセス
```

> **注意**: 自己署名証明書の警告が出た場合は「詳細設定」→「安全でないサイトへ進む」をクリックしてください。

---

##### ステップ2：カメラで血圧計を撮影する

1. 「📷 カメラで撮影」ボタンをタップ
2. カメラが起動したら、血圧計の画面がガイド枠内に入るように調整
3. 「📸 シャッター」をタップして撮影
4. 撮影された画像がプレビューに表示される

> **撮影のコツ**:
> - 血圧計の数字がガイド枠の中央に来るように持つ
> - 画面に反射・光が映り込まないようにする
> - なるべく明るい場所で撮影する

---

##### ステップ3：画像を確定する

プレビューを確認して、以下のボタンを操作します。

| ボタン | 操作 |
|---|---|
| 「✓ この画像を使う」 | 画像を確定してOCRを開始する |
| 「🔄 回転」 | 画像の向きを90度回転する |
| 「🔄 再撮影」 | 撮り直す |

「この画像を使う」をタップすると、カメラが閉じて **OCRが自動で開始**されます。

---

##### ステップ4：OCR処理中の表示を確認する

画像プレビューの下に **青いバナー** が表示されます。

```
⟳ 読み取り中…
```

> OCRの処理には**初回5〜20秒程度**かかります（言語データのダウンロードのため）。  
> 2回目以降はキャッシュが効いて速くなります。処理中は他の操作をせずお待ちください。

---

##### ステップ5：認識結果を確認する

処理が完了すると、バナーの内容が切り替わります。

**【成功した場合】** 緑のバナーが表示される

```
✓ 認識結果を確認してください

[そのまま記録]  [修正する]  ([再試行] ※低信頼度の場合のみ)
```

フォームの「最高血圧」「最低血圧」「脈拍」に数値が自動入力され、各フィールドの横に信頼度バッジが表示されます。

**【失敗した場合】** 赤いバナーが表示される

```
✕ 自動読み取りに失敗しました。手動で入力するか再試行してください

[再試行]
```

フォームには値が入力されませんが、手動で直接入力できます。

---

##### ステップ6：内容を確認・修正する

自動入力された値を目視で確認します。信頼度バッジの色に注目してください。

- **緑（✓）のフィールド**: そのままで問題ないと思われます
- **黄（!）のフィールド**: 念のため画像と比較して確認してください
- **赤（✕）のフィールド**: 誤認識の可能性が高いため、手動で修正してください

フィールドの値を**手動で書き換えると**、バッジが `✎ 編集済` に変わり、手動入力した値が保存されます。

> 「修正する」ボタンを押すと、最高血圧のフィールドにカーソルが移動して入力しやすくなります。

---

##### ステップ7：記録する

確認・修正が完了したら、いずれかの方法で記録できます。

| 操作 | 説明 |
|---|---|
| バナーの「**そのまま記録**」ボタン | OCR結果（または編集済みの値）を記録する |
| フォーム下の「**記録する**」ボタン | 同じく記録する（どちらを使っても同じ） |

記録が成功すると、画像プレビューとOCRバナーが消え、記録一覧に追加されます。

---

#### シナリオ別テスト手順

実装の品質を確認するため、以下のシナリオも順番に試してみてください。

##### シナリオA：成功〜そのまま記録

1. 血圧計を撮影 → 「この画像を使う」
2. OCRが完了し、フォームに値が入力されることを確認
3. 信頼度バッジが表示されることを確認
4. バナーの「そのまま記録」をタップ
5. 記録一覧に追加されることを確認

##### シナリオB：成功〜一部修正して記録

1. 血圧計を撮影 → OCR完了
2. 「最高血圧」フィールドの値を手動で書き換える
3. そのフィールドのバッジが「✎ 編集済」に変わることを確認
4. 他のフィールドのバッジは変わっていないことを確認
5. 「そのまま記録」または「記録する」で保存
6. 記録一覧の値が**手動で入力した値**になっていることを確認

##### シナリオC：失敗〜再試行〜成功

1. 真っ暗な場所や、血圧計が映っていない画像で試す
2. 「✕ 失敗」バナーが表示されることを確認
3. 「再試行」ボタンをタップ
4. OCRが再実行されることを確認（再試行は最大3回まで）
5. 3回失敗したら「再試行の上限に達しました」と表示されることを確認

##### シナリオD：失敗〜手動入力で記録

1. OCRが失敗しても、フォームに手動で値を入力できることを確認
2. 「記録する」ボタンで通常通り保存できることを確認

##### シナリオE：画像削除でリセットされる

1. OCR完了後（バナー表示中）に、画像プレビューの「✕」ボタンで画像を削除
2. OCRバナーが消えることを確認
3. フォームの自動入力が消え、信頼度バッジも非表示になることを確認

---

#### デバッグモードでのテスト

URLに `?debug=1` を追加すると、OCRの詳細情報を開発者ツールで確認できます。

```
http://localhost:8000/?debug=1
```

ブラウザの開発者ツール（F12）→ **Console** タブで以下のようなログが確認できます。

```
[OCR AutoRun] OCR開始
[OCR AutoRun] 認識完了 (8432ms)
[OCR AutoRun] 抽出結果: { systolic: 120, diastolic: 78, pulse: 65, confidence: 87 }
```

---

#### よくある問題と対処法

| 症状 | 原因 | 対処法 |
|---|---|---|
| バナーが表示されない | 画像未選択またはOCRモジュール未読込 | ページをリロードして再試行 |
| 数値が明らかに間違っている | 照明不足・反射・画角のずれ | 再撮影して照明を改善する |
| 処理が長い（30秒以上） | 言語データのダウンロード中 | 通信環境を確認してそのまま待つ |
| OCR中に操作できない | 意図的な制御（多重実行防止） | 処理完了まで待つ |
| 「再試行の上限」と表示される | 3回連続して失敗した | 「📷 カメラで撮影」から撮り直す |

---

### 今後の予定（Phase 3 後続Step）
- ✅ 画像前処理のさらなる最適化（前処理A/B/C多重試行） ← Step 3-5 で完了
- ✅ 認識結果の自動入力（フォームへの値のセット） ← Step 3-4 で完了
- ✅ PSMの最適化（複数PSMを自動探索） ← Step 3-5 で完了
- 言語データのローカル配置（オフライン最適化）
- テスト画像セットの拡充（照明・機種差・角度差のカバレッジ向上）

---

## OCR精度の最適化（Phase 3 Step 3-5）

### 概要

Step 3-5 では、血圧計の写真の読み取り精度をさらに上げるための仕組みを追加しました。  
1枚の画像に対して「前処理方法」「Tesseractの設定（PSM）」「解像度」を変えながら**複数回試行し、最も良い結果を自動で選ぶ**ようになりました。

#### 追加された主な機能

| 機能 | 説明 |
|---|---|
| **多重試行（Multi-attempt）** | 前処理A/B/C × PSM7/6/8 × 解像度640/960/1280 の組み合わせを順番に試行し、最高スコアの結果を採用 |
| **早期確定** | スコアが閾値（85点）を超えたら、残りの試行を省略して即座に確定（速度改善） |
| **タイムアウト** | 10秒を超えた場合は、その時点のベスト結果を返す（フリーズ防止） |
| **Strict/Relaxed 判定** | 高信頼度の場合は自動入力OK、中〜低信頼度は「要確認」として表示 |
| **誤読補正の強化** | `O→0`、`I→1` に加え、`120:80` のように `:` で区切られた数字を `/` に正規化 |
| **デバッグパネル** | `?debug=1` で各試行の前処理サムネイル・スコア・rawText を画面で確認できる |
| **撮影ヒント** | OCR失敗時に、撮影改善のためのヒントが1件表示される |

---

### 動作確認手順（初心者向け・段階ごとの説明）

以下の手順を **ステップ1から順番に** 試してください。  
各ステップの「確認ポイント」で、期待通りの動作になっているかを確かめながら進めます。

---

#### ステップ1：アプリを起動する

**操作**

```bash
# Python 3 がある場合（おすすめ）
python -m http.server 8000
```

ブラウザで `http://localhost:8000` を開きます。

> **Androidスマートフォンで試す場合**  
> PCと同じWi-Fiにつないだ状態で、PCのIPアドレス（例：`http://192.168.1.10:8000`）をスマホのブラウザで開いてください。

**確認ポイント**
- 「血圧記録アプリ」のページが表示される
- ブラウザのコンソール（F12 → Consoleタブ）に以下が出ている

```
[OCR] モジュール読み込み完了（多重試行対応版）
App initialized
```

---

#### ステップ2：デバッグモードで開く

URLの末尾に `?debug=1` を追加してアクセスします。

```
http://localhost:8000/?debug=1
```

**確認ポイント**
- 「🔍 OCRテスト」ボタンが「📷 カメラで撮影」ボタンの横に表示される
- コンソールに以下が出ていれば正常です

```
[OCR Test] デバッグモード有効 - OCRテストボタンを表示します
```

> **デバッグモードについて**  
> URLに `?debug=1` がある間だけ詳細情報が表示されます。  
> 通常利用（パラメータなし）では何も変わりません。ご家族に使わせる際はそのままで問題ありません。

---

#### ステップ3：サンプル画像でOCRテストを実行する（画像なしでも可）

デバッグモードで表示された「🔍 OCRテスト」ボタンをクリックします。  
血圧計の画像がなくても、アプリが自動でサンプル画像（`120 / 80`と`75`の数字を描いた画像）を作って試行してくれます。

**操作**
1. 「🔍 OCRテスト」ボタンをクリック
2. ボタンが「🔍 認識中...」に変わり、処理が始まる（初回は言語データのDLで30秒ほどかかる場合があります）
3. 処理が終わるとアラートが表示される

**確認ポイント**
- アラートに認識テキスト・信頼度・処理時間が表示される
- 画面下部に「前処理デバッグ」パネルが現れ、白黒に変換された画像のサムネが並ぶ

---

#### ステップ4：コンソールで多重試行のログを確認する

開発者ツール（F12）の **Console** タブを開きます。  
OCRが実行されると、以下のようなログが流れます。

```
[OCR] 多重試行開始 (最大24件, timeout=10000ms)
[OCR] attempt A_PSM7_640 score=72 BP=120/80 PUL=65 (1243ms)
[OCR] attempt A_PSM6_640 score=68 BP=120/80 PUL=65 (1100ms)
[OCR] 早期確定 (score=89)
[OCR] 多重試行完了: 3件, 3420ms, best=A_PSM7_640(score=89)
[OCR AutoRun] 認識完了 (3420ms, attempts=3)
[OCR AutoRun] 抽出結果: { systolic: 120, diastolic: 80, pulse: 65, confidenceLevel: "high", needsReview: false, selectedAttempt: "A_PSM7_640" }
```

**ログの見方**

| ログの内容 | 意味 |
|---|---|
| `attempt A_PSM7_640` | 前処理パターンA、PSM=7、解像度640px での試行 |
| `score=89` | この試行の総合スコア（100点満点。85点以上で早期確定） |
| `BP=120/80` | 最高血圧120 / 最低血圧80 と認識した |
| `早期確定` | スコアが閾値を超えたため、残りの試行を省略した |
| `best=A_PSM7_640` | この試行の結果が最終的に採用された |
| `confidenceLevel: "high"` | 高信頼度（自動入力OK、要確認なし） |
| `needsReview: false` | 要確認フラグなし |

**確認ポイント**
- `多重試行完了` のログが出ている
- `best=` にどの試行が選ばれたか表示されている
- `confidenceLevel` が `high` / `medium` / `low` のいずれかになっている

---

#### ステップ5：デバッグパネルで各試行の詳細を確認する

カメラで血圧計を撮影して「この画像を使う」を押すと（またはOCRテストを実行すると）、  
**画面下部に黒背景のデバッグパネル**が表示されます。

```
OCR多重試行デバッグ（開発用）  ▼
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
試行数: 3 / 所要時間: 3420ms / 採用: A_PSM7_640

[A_PSM7_640] [score=89] ← 青枠（採用された試行）
  [白黒サムネイル画像]
  raw: "120/80 65"
  OCR conf=91 / extract=85 / total=89
  SYS=120 DIA=80 PUL=65 level=high

[A_PSM6_640] [score=72]
  ...

[ログをJSON保存] ボタン
```

**パネルの見方**

| 表示 | 意味 |
|---|---|
| 青枠の試行 | 最終的に採用された試行 |
| 白黒サムネイル | その試行で使われた前処理後の画像 |
| `raw:` | Tesseractが認識した生のテキスト |
| `OCR conf=` | Tesseractの生の認識信頼度（0〜100） |
| `extract=` | 血圧値の抽出スコア（0〜100） |
| `total=` | 総合スコア（`conf×0.4 + extract×0.6`） |
| `level=high/medium/low` | 最終的な信頼度ランク |

**確認ポイント**
- 複数の試行が並んで表示されている（最低2〜3個）
- 青枠の試行が1つだけある（採用された試行）
- 「ログをJSON保存」ボタンをクリックすると、試行結果全体がJSONファイルでダウンロードされる

---

#### ステップ6：通常の撮影でOCRの動作を確認する

デバッグモードを外して、実際の血圧計で動作確認をします。

**操作**
1. `http://localhost:8000/`（`?debug=1` なし）でアプリを開く
2. 「📷 カメラで撮影」をタップ
3. 血圧計の画面をガイド枠に合わせて撮影
4. 「✓ この画像を使う」をタップ
5. 「読み取り中…」のバナーが表示される
6. 完了後に結果を確認する

**確認ポイント（成功した場合）**

```
✓ 高信頼度で認識しました。確認してください    ← confidenceLevel=high のとき
  または
✓ 認識結果を確認してください                  ← medium のとき
  または
! 信頼度が低い項目があります。内容を確認してください  ← low のとき

[そのまま記録]  [修正する]  ([再試行] ※低信頼度時のみ)
```

**確認ポイント（失敗した場合）**

```
✕ 血圧値を認識できませんでした。手動で入力するか再試行してください
  画面の反射を避けてください  ← 撮影ヒントがランダムで表示される

[再試行]
```

---

#### ステップ7：信頼度レベルによる動作の違いを確認する

Step 3-5 から、認識結果が3段階に分類されるようになりました。

| `confidenceLevel` | `needsReview` | バナーメッセージ | 「再試行」ボタン |
|---|---|---|---|
| `high`（高） | `false` | 「✓ 高信頼度で認識しました」 | 表示されない |
| `medium`（中） | `true` | 「✓ 認識結果を確認してください」 | 表示されない |
| `low`（低） | `true` | 「! 信頼度が低い項目があります」 | 表示される |

**確認ポイント**
- 鮮明な画像では `high` になりやすい
- ぼやけた画像や斜めから撮影した画像では `medium` または `low` になる
- `low` のときに「再試行」ボタンが表示される

---

#### ステップ8：早期確定とタイムアウトを確認する（発展）

> このステップは開発者向けです。初心者の方は省略してかまいません。

**早期確定の確認**

コンソールのログで `[OCR] 早期確定` が表示された場合は、少ない試行回数で素早く完了しています。  
`score=85` 以上に達した試行があれば、残りの試行は実行されません。

**タイムアウトの確認**

`js/constants.js` の `OCR_TOTAL_TIMEOUT_MS` を短い値（例：`1000`）に変更して試行すると、  
タイムアウト時にベスト候補が返されるか、失敗表示になるかを確認できます。

> 確認後は必ず `10000`（10秒）に戻してください。

---

#### ステップ9：セルフテストを実行する

ブラウザのコンソールから、文字認識ロジックの自己テストを実行できます。

**操作**
1. F12でコンソールを開く
2. 以下をコピーして貼り付け、Enterキーを押す

```javascript
window.OCR.runExtractionSelfTest()
```

**期待される出力**

```
[OCR Self-Test] 開始... (11 ケース)
[PASS] 標準パターン (XXX/YYY ZZZ)
[PASS] ラベル付きパターン (SYS DIA PUL)
[PASS] 全角混在 (１２０／８０ ６５)
[PASS] セパレータ欠落 (120 80 65)
[PASS] 改行分断 (120\n80\n65)
[PASS] 誤認識 O→0 (12O/8O 65)
[PASS] 最高/最低が反転 (80/120) → BP null
[PASS] 範囲外データ (999/10 65) → BP null, pulse 65
[PASS] 空テキスト → 全 null
[PASS] BPMラベル付き脈拍 (130/85 72BPM)
[PASS] 区切り記号 : を / に正規化 (120:80 65)
[OCR Self-Test] 完了: 11/11 PASS, 0 FAIL
```

**確認ポイント**
- すべて `[PASS]` になっていることを確認
- `[FAIL]` がある場合は、認識ロジックに問題がある可能性があります

---

### シナリオ別テスト手順（Phase 3 Step 3-5）

実装の品質を確認するため、以下のシナリオも順番に試してみてください。

---

#### シナリオA：鮮明な画像で早期確定する

1. 明るく正面から撮影した鮮明な血圧計の写真を使う
2. OCR完了後、コンソールで `[OCR] 早期確定` のログを確認する
3. 試行数が少ない（3件以下）ことを確認する
4. バナーに「✓ 高信頼度で認識しました」と表示されることを確認する

---

#### シナリオB：ぼやけた画像で複数試行される

1. 少しぼかした画像や、斜めから撮影した画像を使う
2. コンソールで複数の `attempt` ログが流れることを確認する
3. `早期確定` ログが出ない（=複数の試行が必要だった）ことを確認する
4. バナーが「! 信頼度が低い項目があります」になる場合があることを確認する

---

#### シナリオC：OCR失敗時に撮影ヒントが出る

1. 真っ暗な場所や、血圧計が映っていない画像を使う
2. 「✕ 失敗」バナーが表示されることを確認する
3. バナーの下に**撮影ヒント**（例：「画面の反射を避けてください」）が1件表示されることを確認する
4. 「再試行」をクリックするとOCRが再実行されることを確認する
5. 3回連続で失敗すると「再試行の上限に達しました」と表示されることを確認する

---

#### シナリオD：タイムアウト動作の確認（発展）

1. `js/constants.js` の `OCR_TOTAL_TIMEOUT_MS` を `2000`（2秒）に一時変更する
2. OCRを実行し、コンソールで `[OCR] タイムアウト` のログが出ることを確認する
3. フリーズせず、失敗バナーまたは不完全な結果が表示されることを確認する
4. 確認後、`OCR_TOTAL_TIMEOUT_MS` を `10000` に戻す

---

#### シナリオE：デバッグパネルのJSONダウンロード

1. `?debug=1` でアプリを開き、OCRを実行する
2. 画面下部のデバッグパネルの「**ログをJSON保存**」ボタンをクリックする
3. `ocr-debug-XXXXXXXXXX.json` というファイルがダウンロードされる
4. ファイルを開き、以下の構造が含まれていることを確認する

```json
{
  "timestamp": "...",
  "selectedAttemptId": "A_PSM7_640",
  "totalElapsedMs": 3420,
  "errorCode": null,
  "attempts": [
    {
      "id": "A_PSM7_640",
      "preprocessName": "A",
      "resolutionLevel": 640,
      "tesseract": { "psm": 7 },
      "rawText": "120/80 65",
      "confidence": 91,
      "totalScore": 89,
      "vitals": { "systolic": 120, "diastolic": 80, "pulse": 65, "confidenceLevel": "high" },
      ...
    }
  ]
}
```

---

### よくある問題と対処法（Phase 3 Step 3-5）

| 症状 | 原因 | 対処法 |
|---|---|---|
| 多重試行ログが出ない | `ocr.js` が古いキャッシュで動いている | Ctrl+Shift+R（強制リロード）またはキャッシュクリア |
| デバッグパネルが出ない | `?debug=1` がURLにない | URLに `?debug=1` を追加する |
| 試行数が1件しかない | 早期確定が発動している | 意図的な動作。スコアが85以上なら正常 |
| 処理が遅い（10秒以上） | 低スコアが続き全試行を消化している | 撮影状態を改善するか、タイムアウト値を下げてテスト |
| セルフテストで FAIL が出る | 認識ロジックに問題がある | `js/ocr.js` の変更内容を確認する |
| JSONが保存されない | ポップアップブロックの干渉 | ブラウザのポップアップ許可設定を確認する |

---

### 設定値の調整方法（js/constants.js）

精度や速度に関わる主要な設定は `js/constants.js` の `OCR_CONSTANTS` に集約されています。  
実際に試しながら数値を変えて最適化できます。

```javascript
const OCR_CONSTANTS = {
    ATTEMPTS_MAX: 24,           // 最大試行数（増やすと精度↑、遅くなる）
    OCR_TOTAL_TIMEOUT_MS: 10000, // タイムアウト（ミリ秒）
    SCORE_EARLY_ACCEPT: 85,     // 早期確定スコア（下げると速い、精度は落ちる）
    CONFIDENCE_HIGH: 80,        // 「高信頼度」と判定するスコア
    CONFIDENCE_MEDIUM: 60,      // 「中信頼度」と判定するスコア
    OCR_CONF_WEIGHT: 0.4,       // OCR信頼度の重み（合計 CONF + EXTRACT = 1.0）
    EXTRACT_WEIGHT: 0.6,        // 抽出スコアの重み
};
```

**調整の目安**

| やりたいこと | 変更する定数 | 変更方向 |
|---|---|---|
| もっと速く処理したい | `SCORE_EARLY_ACCEPT` | 下げる（例：75） |
| もっと精度を上げたい | `SCORE_EARLY_ACCEPT` | 上げる（例：90） |
| タイムアウトを短くしたい | `OCR_TOTAL_TIMEOUT_MS` | 下げる（例：6000） |
| 「要確認」の基準を厳しくしたい | `CONFIDENCE_HIGH` | 上げる（例：85） |

---

## ライセンス
このプロジェクトは個人用途での使用を想定しています。

## 貢献
バグ報告や機能提案は、Issueでお知らせください。
