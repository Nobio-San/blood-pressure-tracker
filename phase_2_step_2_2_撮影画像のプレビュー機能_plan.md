## 前提・要約
- 目的：Phase 2「カメラ撮影機能」のうち、Step 2-2として「撮影直後に画像をフルスクリーンでプレビューし、再撮影 or 採用を選べる」体験を実装する。
- 成果物：
  - 撮影→プレビュー→（再撮影 | この画像を使う）までの一連のUI/状態遷移
  - 画像の一時保存（Base64）とメモリリーク対策
  - 画像の縮小最適化（長辺1280px目安）
  - 画像向き補正（可能な範囲でEXIF/端末向きに対応し、フォールバックを用意）
- 対象の種類（推定）：新規実装（Phase 2で camera.js を新規作成し、Step 2-2でプレビュー画面と画像処理を追加するため）
- 成功条件（Done）：
  - 撮影後にプレビュー画面が表示され、画像が崩れずに確認できる
  - 「再撮影」でカメラプレビューへ戻れる
  - 「この画像を使う」で撮影画像が Base64 として一時保存され、次Step（2-4）で利用できる形に保管できる
  - 画像が長辺1280px程度に縮小され、端末での表示/保存が重くならない
  - 画像向きが明らかにおかしいケースに対して、補正または回避策（ガイド/回転ボタン/自動補正のフォールバック）のどれかが提供される
- 前提（仮定した点があれば明記）：
  - Step 2-1（カメラアクセス/撮影/キャプチャ）が完了しており、video→canvas キャプチャが可能な状態
  - プレビューはモーダル内で完結し、撮影から入力画面への紐付け（Step 2-4）は「採用した画像を sessionStorage に保存」までをここで担当する
  - 対象は Android（PWA）中心だが、ブラウザ差分は最低限考慮する
- 主要な制約：
  - PWA/ブラウザ環境のため、端末やブラウザで Camera / ImageCapture / EXIF 取り扱いが異なる
  - Base64 はサイズ増加があるため、縮小・圧縮が前提
- 既知の不明点（あれば）：
  - Step 2-1 の実装が video+canvas 方式か、ImageCapture API を併用しているか（向き補正の手段に影響）

## 全体ステップ構成
- Step1: 要件・状態遷移とI/F（保存形式/キー/呼び出し関数）の整理
- Step2: UI（プレビュー画面）実装（HTML/CSS）
- Step3: 画像処理（縮小/圧縮/向き補正）実装
- Step4: 一時保存・クリーンアップ（メモリリーク対策）実装
- Step5: 動作確認・エッジケーステスト

---

## Step1: 要件・状態遷移とI/F整理
### Plan 1: プレビュー機能の状態遷移（state machine）と責務分割を決める
- 目的：撮影→プレビュー→採用/再撮影の状態遷移を明文化し、camera.js の責務をぶれなく実装できるようにする。
- 作業内容（チェックリスト）：
  - [ ] 画面状態を定義（例：`CAMERA_PREVIEW` / `PHOTO_PREVIEW` / `PROCESSING`）
  - [ ] イベントを定義（撮影、再撮影、採用、閉じる、エラー）
  - [ ] 「採用」時に外部へ渡すデータ形式を定義（Base64 文字列、画像メタ情報）
  - [ ] sessionStorage の保存キーと保存タイミングを決める（例：`bp:lastCapturedImage`）
  - [ ] 次Step（2-4）で読み出せる最低限のペイロードを決める（例：`{ base64, createdAt, width, height }`）
- 変更対象（想定ファイル/モジュール）：
  - `js/camera.js`
  - （必要なら）`js/app.js`（採用後に入力画面へ反映するフックだけ先に作る場合）
- 受け入れ基準（完了条件）：
  - 状態遷移図/箇条書きが README またはコメントとして残り、実装の参照点になる
- テスト/検証：
  - 状態遷移の想定ケースを5パターン程度書き出し、矛盾がないことを確認
- 依存関係・注意点：
  - Step 2-1 の撮影方法（canvas or ImageCapture）によって、向き補正の戦略が変わる
- リスクと回避策：
  - リスク：向き補正が端末依存で破綻
  - 回避策：自動補正が効かない場合のフォールバック（手動回転ボタン or 注意文）を最初から要件に含める

---

## Step2: UI（プレビュー画面）実装
### Plan 1: プレビュー画面（フルスクリーン/モーダル）を追加する
- 目的：撮影後に画像を大きく表示し、「再撮影」「この画像を使う」を確実に操作できるUIを提供する。
- 作業内容（チェックリスト）：
  - [ ] プレビュー用コンテナを用意（モーダル内で video 表示領域と排他）
  - [ ] `<img>` または `<canvas>` で撮影画像を表示できる領域を追加
  - [ ] 「再撮影」「この画像を使う」ボタンを視認性高く配置（親指到達圏、44–48px以上）
  - [ ] 処理中（縮小/圧縮）のローディング表示（スピナー/テキスト）を追加
  - [ ] アクセシビリティ最低限：フォーカス移動、`aria-label`、閉じる導線
- 変更対象（想定ファイル/モジュール）：
  - `index.html`
  - `css/style.css`
- 受け入れ基準（完了条件）：
  - 撮影後にプレビュー表示へ切り替わり、ボタン操作が迷わず可能
  - 処理中は連打できない（ボタン disabled + ローディング表示）
- テスト/検証：
  - Android Chromeで、縦/横それぞれでプレビューが画面内に収まり、ボタンが押しやすい
- 依存関係・注意点：
  - 画像表示は後続の画像処理（縮小）完了後に差し替える想定（先に仮表示→処理完了後に最適化版へ、も可）
- リスクと回避策：
  - リスク：フルスクリーンでアドレスバーやSafe Areaによりボタンが隠れる
  - 回避策：`env(safe-area-inset-*)` を考慮した余白、`position: sticky` などでボタン固定

### Plan 2: プレビュー操作（再撮影/採用）のイベントハンドラを実装する
- 目的：ユーザー操作で確実に状態が遷移し、カメラストリームや一時データが破綻しないようにする。
- 作業内容（チェックリスト）：
  - [ ] 撮影後：`CAMERA_PREVIEW` → `PROCESSING` → `PHOTO_PREVIEW` の遷移
  - [ ] 「再撮影」：プレビュー画像を破棄し、必要ならストリーム再開して `CAMERA_PREVIEW` に戻る
  - [ ] 「この画像を使う」：最適化済み画像を一時保存し、モーダルを閉じる（or 次の導線へ）
  - [ ] 連打/二重実行防止（状態でガード）
- 変更対象（想定ファイル/モジュール）：
  - `js/camera.js`
- 受け入れ基準（完了条件）：
  - 「再撮影」で毎回撮影が可能（真っ黒/フリーズしない）
  - 「この画像を使う」で保存が成功し、閉じる導線が一貫している
- テスト/検証：
  - 10回連続で「撮影→再撮影」を繰り返しても落ちない/重くならない
- 依存関係・注意点：
  - Step 2-1 でストリーム停止/再開の方針がある場合、それに合わせる
- リスクと回避策：
  - リスク：再撮影で stream が止まったままになる
  - 回避策：`startCamera()` / `stopCamera()` の呼び出し責務を明確化し、どの状態で何を呼ぶか固定

---

## Step3: 画像処理（縮小/圧縮/向き補正）実装
### Plan 1: 画像縮小（長辺1280px目安）と圧縮方針を実装する
- 目的：保存/表示コストを抑えつつ、OCR（Phase 3）に必要な視認性を残す。
- 作業内容（チェックリスト）：
  - [ ] 縮小ターゲットを決定（長辺 1280px、画質 0.8 などの初期値）
  - [ ] canvas を用いたリサイズ処理を実装（入力：captured canvas / blob、出力：最適化済み画像）
  - [ ] 出力形式を決定（基本は JPEG、文字が潰れるなら PNG も検討）
  - [ ] Base64 生成（`toDataURL` or `toBlob + FileReader`）のいずれかで実装
  - [ ] 例外処理（極端に小さい/大きい、処理失敗）で元画像をフォールバック表示
- 変更対象（想定ファイル/モジュール）：
  - `js/camera.js`
  - （任意）`js/image-utils.js`（画像処理を分離してテストしやすくする場合）
- 受け入れ基準（完了条件）：
  - 代表的な端末で撮影した画像が、長辺1280px程度に縮小されてプレビュー表示される
  - 生成した Base64 のサイズが過剰に大きくならない（例：数MBを超えにくい）
- テスト/検証：
  - 明るい/暗い環境で撮影し、数字が読めること（OCR前提の視認性）
  - 生成画像の幅/高さが意図通りか（console ではなく表示や簡易メタ表示で確認）
- 依存関係・注意点：
  - Phase 3（OCR）の精度を下げないよう、圧縮しすぎない（初期は安全側）
- リスクと回避策：
  - リスク：圧縮で数字が潰れてOCR精度が落ちる
  - 回避策：品質パラメータを定数化し、後から調整しやすくする（設定化はPhase 4でも良い）

### Plan 2: 向き補正の戦略を実装（自動 + フォールバック）
- 目的：撮影画像の回転ズレを最小化し、少なくとも「ユーザーが詰まらない」導線を用意する。
- 作業内容（チェックリスト）：
  - [ ] まずは Android Chrome の video→canvas キャプチャで向きが崩れる代表ケースを把握（端末縦持ち/横持ち）
  - [ ] 自動補正案：
    - 端末向き（`screen.orientation` / `window.orientation` 互換）と video の実解像度（track settings）から回転角を推定して描画時に回転
    - （可能なら）ImageCapture `takePhoto()` が使える場合は blob から `createImageBitmap({ imageOrientation: 'from-image' })` で補正
  - [ ] フォールバック：プレビュー画面に「90°回転」ボタンを用意（自動補正が失敗しても救える）
  - [ ] 回転操作後も、最適化→Base64保存に反映されるようにする
- 変更対象（想定ファイル/モジュール）：
  - `js/camera.js`
  - `index.html`, `css/style.css`（回転ボタンを追加する場合）
- 受け入れ基準（完了条件）：
  - 少なくとも主要端末で「明らかに横倒し」にならない、または回転ボタンで修正できる
  - 回転後の画像が「この画像を使う」で保存され、後続で参照できる
- テスト/検証：
  - 端末縦持ち/横持ちで撮影し、表示向きが妥当か確認
  - 自動補正が効かない場合でも、回転ボタンで救えるか確認
- 依存関係・注意点：
  - EXIF は「写真ファイル（blob）」にはあり得るが、「canvas起点の画像」には基本的に付かない点に注意
- リスクと回避策：
  - リスク：端末/ブラウザ差分で自動推定が外れる
  - 回避策：手動回転フォールバックを必須にし、自動補正はベストエフォートにする

---

## Step4: 一時保存・クリーンアップ（メモリリーク対策）
### Plan 1: Base64 の一時保存とデータライフサイクルを実装する
- 目的：次Step（2-4）で画像を利用できるようにしつつ、保存しっぱなし/肥大化を防ぐ。
- 作業内容（チェックリスト）：
  - [ ] sessionStorage に保存（キー/スキーマを Step1 の定義通りに）
  - [ ] 既存データがある場合の上書き/破棄ルールを決める（1件のみ保持など）
  - [ ] 「閉じる」や「再撮影」で不要になったデータを破棄
  - [ ] 画像サイズが大きすぎる場合のガード（保存失敗時のメッセージ + 画質を下げて再生成 or 保存せず継続）
- 変更対象（想定ファイル/モジュール）：
  - `js/camera.js`
- 受け入れ基準（完了条件）：
  - 採用した画像が sessionStorage に保存され、ページリロード無しで参照できる
  - 再撮影/キャンセル時に不要データが残らない
- テスト/検証：
  - 連続撮影で sessionStorage が意図通り上書きされる
  - 保存が失敗した場合もUIが固まらず復帰できる
- 依存関係・注意点：
  - sessionStorage はタブ単位。家族利用想定で必要なら later に localStorage/DB へ拡張
- リスクと回避策：
  - リスク：Base64 が大きく保存上限に当たる
  - 回避策：縮小/圧縮を先に行う、失敗時は品質を段階的に下げる（ただしOCR前提で下げすぎない）

### Plan 2: メモリリーク対策（ストリーム/オブジェクトURL/イベント）を入れる
- 目的：撮影を繰り返しても重くならない/落ちない実装にする。
- 作業内容（チェックリスト）：
  - [ ] `URL.createObjectURL` を使う場合は必ず `URL.revokeObjectURL`
  - [ ] `canvas` 参照や巨大な Base64 をグローバルに残し続けない（必要最小限に）
  - [ ] モーダルclose時にイベントリスナ重複登録が起きないよう整理
  - [ ] 必要に応じてカメラストリーム停止のタイミングを統一（閉じる/採用/エラー）
- 変更対象（想定ファイル/モジュール）：
  - `js/camera.js`
- 受け入れ基準（完了条件）：
  - 「撮影→再撮影」を複数回繰り返しても、体感で重くならない
  - 画面遷移後にカメラが掴みっぱなしにならない
- テスト/検証：
  - 連続撮影（10〜20回）でフリーズ/クラッシュがない
- 依存関係・注意点：
  - Android 端末はメモリ制約が強い機種もあるため、保守的に設計する
- リスクと回避策：
  - リスク：端末によっては停止/再開のたびに黒画面
  - 回避策：`stopCamera()` の呼び出し条件を絞り、再撮影時はストリーム維持も選べるよう設計（まずは安定優先）

---

## Step5: 動作確認・エッジケーステスト
### Plan 1: 手動テストシナリオを作って検証する
- 目的：実機に近い条件で詰まりやすい箇所（権限/向き/暗所/連続撮影）を潰す。
- 作業内容（チェックリスト）：
  - [ ] 撮影→プレビュー表示→採用→（次Step用にsessionStorageに残る）
  - [ ] 撮影→プレビュー→再撮影→再度撮影→採用
  - [ ] 端末縦/横で撮影し、向きが破綻しない or 回転で救える
  - [ ] 暗所/反射ありで撮影し、プレビューで読める品質か
  - [ ] 連続撮影 10〜20回で落ちない
  - [ ] 権限拒否/カメラ不可端末のときに、適切なエラーメッセージが出る（Step 2-1 実装に合わせて）
- 変更対象（想定ファイル/モジュール）：
  - 必要に応じて `js/camera.js`, `css/style.css` の微調整
- 受け入れ基準（完了条件）：
  - 上記シナリオを一通り通し、致命的な詰まりがない
  - 画像表示・操作が直感的で、家族利用（非エンジニア）でも迷いにくい
- テスト/検証：
  - Android Chrome（可能なら別端末 or エミュレーター）で実施
- 依存関係・注意点：
  - OCR導入前なので、ここでは「数字が読める」程度の品質評価に留める
- リスクと回避策：
  - リスク：端末差で向きが不安定
  - 回避策：回転ボタンを残し、次Phaseで端末別チューニングする（対応機種メモを残す）

