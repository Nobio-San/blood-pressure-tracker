## 前提・要約
- 目的：血圧入力フォームで入力した記録を、オフラインでも保持できるようにローカルストレージ（localStorage）へ安全に保存・読み込みできる基盤を作る。
- 成果物：
  - `js/app.js` に「入力→バリデーション→保存」「起動時読み込み」「クリア」の一連処理（＋安全なストレージアクセサ）
  - 保存データのスキーマ（v1）とストレージキー
  - 手動テスト観点（チェックリスト）
- 対象の種類（推定）：新規実装（Phase 1の手動入力版における永続化機能の追加）
- 成功条件（Done）：
  - 入力したデータが localStorage に配列として保存され、リロード後も復元できる
  - 必須・数値範囲などのバリデーションが機能し、エラーがユーザーに分かる形で表示される
  - localStorage が使えない/壊れている/容量超過などのケースで破綻せず、フォールバックまたは明確なエラー表示ができる
  - クリアボタンでフォームがリセットされ、測定日時は現在日時に戻る
- 前提（仮定した点があれば明記）：
  - Step 1-2（入力フォームUI）が完了しており、各入力要素に一意な `id` もしくは `name` が付与されている
  - 「記録する」「クリア」操作はフォーム送信/ボタン押下で発火できる
  - UIメッセージ表示領域（例：`#toast` や `#message`）が無い場合は、最低限 `alert()` で代替し、次StepでUI改善する
- 主要な制約：
  - PWA（Android）想定。ブラウザの localStorage 容量に上限があるため、データ量増加時に考慮が必要
  - Phase 1時点ではクラウド同期前のため、localStorage を一次ソースとして扱う
- 既知の不明点（あれば）：
  - 入力フォームの実際のDOM構造/要素ID（本Planでは「後述のPlan 2で確認」前提で進める）

## 全体ステップ構成
- Step1: データスキーマ・ストレージ設計（後戻り防止）
- Step2: 保存フロー実装（バリデーション〜永続化〜通知）
- Step3: 読み込み・クリア・異常系・テスト整備（安定化）

---

## Step1: データスキーマ・ストレージ設計（後戻り防止）
### Plan 1: 保存データスキーマ（v1）とキー設計
- 目的：後工程（一覧表示/Google Sheets同期/グラフ）でも使い回せる「最小で破綻しないデータモデル」を確定する。
- 作業内容（チェックリスト）：
  - [ ] 保存単位（1レコード）のスキーマを確定
    - 例：`{ id, member, systolic, diastolic, pulse, datetime }`
  - [ ] 日時の持ち方を確定（推奨：`datetime` は ISO 8601、加えて `measuredAt` に epoch(ms) を併記するかを判断）
  - [ ] localStorage のキー名を確定（例：`bp_records_v1`）
  - [ ] 将来の拡張用に「バージョン/マイグレーション方針」をメモ（例：キーのサフィックスで分ける or `schemaVersion` を持つ）
  - [ ] 既定のソート順（保存時は追加、表示時は降順など）を決める
- 変更対象（想定ファイル/モジュール）：
  - `js/app.js`（定数/コメント/型のようなドキュメント的記述）
  - （任意）`README.md`（データ仕様メモ）
- 受け入れ基準（完了条件）：
  - 保存スキーマ（フィールド/型/制約）とキー名が明文化されている
  - 日時の扱い（表示と保存のズレ）に対する方針が決まっている
- テスト/検証：
  - 仕様のレビュー（自分でOK）：ユースケース（一覧/グラフ/同期）に不足がないか確認
- 依存関係・注意点：
  - Step 1-4（一覧表示）と Step 1-7（Sheets連携）がこのスキーマに依存するため、ここで固める
- リスクと回避策：
  - リスク：`datetime-local` の値をそのままISO変換するとタイムゾーンで日付がズレる可能性
  - 回避策：epoch(ms) を併記する、または表示用は入力文字列も保持して変換ルールを統一する

### Plan 2: DOM要素ID/イベント仕様の確認（スパイク）
- 目的：`app.js` 実装に必要なフォーム要素・ボタン・メッセージ領域の実体を確定し、実装の手戻りを減らす。
- 作業内容（チェックリスト）：
  - [ ] 入力フォーム要素の `id/name` を一覧化（member / systolic / diastolic / pulse / datetime）
  - [ ] 「記録する」動作が `submit` か `click` かを確認
  - [ ] 「クリア」ボタンの `type`（button/submit）とイベントを確認
  - [ ] メッセージ表示領域の有無を確認（無ければ追加案を決める：後続Stepで対応でもOK）
- 変更対象（想定ファイル/モジュール）：
  - `index.html`（必要なら `id` 追加 / メッセージ領域追加）
  - `js/app.js`（イベントバインド先の確定）
- 受け入れ基準（完了条件）：
  - 実装で参照するDOM要素が一意に特定でき、イベント発火点が決まっている
- テスト/検証：
  - ブラウザで `document.querySelector(...)` で取得できることを確認
- 依存関係・注意点：
  - Step 1-2 の実装状態に依存
- リスクと回避策：
  - リスク：UI側の `id` が揺れて実装が壊れる
  - 回避策：ここで `data-testid` 的な安定セレクタ（`id`）を固定する

---

## Step2: 保存フロー実装（バリデーション〜永続化〜通知）
### Plan 1: ストレージアクセサ実装（安全な get/set）
- 目的：localStorage の「壊れたJSON」「存在しないキー」「容量超過」などを吸収し、アプリ側の呼び出しを単純化する。
- 作業内容（チェックリスト）：
  - [ ] `loadRecords()`：
    - [ ] キー未存在なら `[]` を返す
    - [ ] JSON parse 失敗時は `[]` にフォールバックし、ユーザー通知（or console）
    - [ ] 配列以外が入っていたら `[]` にフォールバック
  - [ ] `saveRecords(records)`：
    - [ ] JSON stringify して保存
    - [ ] 例外（QuotaExceededError等）を捕捉し、ユーザーに保存失敗を通知
  - [ ] 必要なら `isStorageAvailable()` を用意し、不可ならメモリ内のみで動かす（最低限：保存時に明確なエラー）
- 変更対象（想定ファイル/モジュール）：
  - `js/app.js`
- 受け入れ基準（完了条件）：
  - localStorage が空/破損/容量超過の場合でも例外でアプリが停止しない
  - `loadRecords()` が常に配列を返す
- テスト/検証：
  - 開発者ツールでキーを削除/壊したJSONを入れる/容量を逼迫させる等を行い、挙動を確認
- 依存関係・注意点：
  - 後続のフォーム保存ロジックはこのアクセサを経由する
- リスクと回避策：
  - リスク：プライベートモード等で localStorage が例外を投げる
  - 回避策：`try/catch` で availability 判定、不可時のメッセージを用意

### Plan 2: フォーム送信ハンドラ実装（バリデーション＋保存）
- 目的：ユーザー入力を検証し、仕様どおりのレコードを生成して永続化する。
- 作業内容（チェックリスト）：
  - [ ] submit/click イベントを捕捉し、デフォルト動作（ページリロード）を抑止
  - [ ] 入力値を取得し、型変換（数値化）を行う
  - [ ] バリデーション実装：
    - [ ] 必須チェック（member / systolic / diastolic / pulse / datetime）
    - [ ] 範囲チェック：systolic 50-250、diastolic 30-150、pulse 40-200
    - [ ] `systolic > diastolic` を満たす
  - [ ] レコード生成：
    - [ ] `id`：タイムスタンプ等でユニークに（例：`Date.now()` ベース）
    - [ ] `datetime`：ISO 8601 で保持（Step1の方針に従う）
  - [ ] `records = loadRecords()` → `records.push(record)` → `saveRecords(records)`
  - [ ] 保存成功時のフィードバック（メッセージ表示、必要ならフォームの一部リセット）
- 変更対象（想定ファイル/モジュール）：
  - `js/app.js`
  - （必要なら）`index.html`（メッセージ表示用要素追加）
- 受け入れ基準（完了条件）：
  - 正常入力で保存でき、localStorage に配列としてレコードが追加される
  - 不正入力で保存されず、何がダメかユーザーが分かる
- テスト/検証：
  - 正常系：代表値（120/80/70など）を保存し、Applicationタブで確認
  - 異常系：空/範囲外/最高<=最低/日時未入力で保存されないこと
- 依存関係・注意点：
  - Step 1-4（一覧表示）と連携する場合、保存後に「再描画フック」を作る（例：イベント発火）
- リスクと回避策：
  - リスク：入力値が文字列のまま保存され、後工程で計算/ソートが崩れる
  - 回避策：保存直前に型（number）を保証し、保存後に読み込み直して型を再確認する簡易チェックを入れる

### Plan 3: フィードバックUI（最小）整備
- 目的：保存成功/失敗/バリデーションエラーをユーザーが即座に理解できるようにする（UXの最低ライン）。
- 作業内容（チェックリスト）：
  - [ ] メッセージ表示の方法を決める
    - [ ] 既存の領域があればそこに表示（成功：緑/失敗：赤など）
    - [ ] 無ければ暫定 `alert()`、もしくは軽量なメッセージ領域を `index.html` に追加
  - [ ] 連続保存時にメッセージが上書き/自動消去されるなどの挙動を決める
- 変更対象（想定ファイル/モジュール）：
  - `js/app.js`
  - （必要なら）`index.html`, `css/style.css`
- 受け入れ基準（完了条件）：
  - 成功/失敗がUI上で判別できる
  - エラー内容が「修正行動」に繋がる文言になっている
- テスト/検証：
  - 成功/失敗の双方で表示が出ること
- 依存関係・注意点：
  - 今後のUI改善でトースト等に置き換える前提でも、インターフェース（`showMessage(type, text)` のような関数）で切り出すと移行が楽
- リスクと回避策：
  - リスク：alert連打でUXが悪化
  - 回避策：可能ならメッセージ領域方式に寄せ、alertはlocalStorage不可など致命的ケースのみ

---

## Step3: 読み込み・クリア・異常系・テスト整備（安定化）
### Plan 1: 起動時のデータ読み込み（初期化）
- 目的：ページリロード後も「保存済みデータが利用可能」な状態を作る（次の一覧表示/グラフの前提）。
- 作業内容（チェックリスト）：
  - [ ] DOMContentLoaded 等で `loadRecords()` を呼び、メモリ上の `records` を初期化
  - [ ] データ未存在時は空配列で初期化（エラーにしない）
  - [ ]（任意）デバッグ用に件数を表示/console出力（開発中のみ）
- 変更対象（想定ファイル/モジュール）：
  - `js/app.js`
- 受け入れ基準（完了条件）：
  - 保存済みデータがある場合、リロードしても `loadRecords()` で取得できる
  - データが無くてもエラーが出ず、初回利用できる
- テスト/検証：
  - 1件保存→リロード→取得件数が維持される

### Plan 2: クリアボタン処理（フォームリセット＋日時リセット）
- 目的：入力のやり直しを素早く行えるようにし、日時は常に「今」を初期値に戻す。
- 作業内容（チェックリスト）：
  - [ ] クリアボタンの click を捕捉（submitにならないように）
  - [ ] フォームを reset
  - [ ] `datetime-local` を「現在日時」にセットし直す（表示上のフォーマットに注意）
  - [ ] 必要ならメッセージ/エラー表示状態もクリア
- 変更対象（想定ファイル/モジュール）：
  - `js/app.js`
- 受け入れ基準（完了条件）：
  - クリア後、全項目が初期状態に戻り、日時が現在に更新される
- テスト/検証：
  - 値を入れてクリア→空に戻る、日時が更新される
- 依存関係・注意点：
  - `datetime-local` は `YYYY-MM-DDTHH:mm` 形式が必要（秒無し）
- リスクと回避策：
  - リスク：日時フォーマット不一致で反映されない
  - 回避策：日時セットのユーティリティ関数化＋手動確認

### Plan 3: 異常系ハンドリング強化（フォールバック方針確定）
- 目的：端末/ブラウザ差や容量問題でもアプリが壊れず、ユーザーが行動できる状態を維持する。
- 作業内容（チェックリスト）：
  - [ ] localStorage 不可（例外/undefined）の検出とメッセージ
  - [ ] JSON破損時：
    - [ ] `[]` にフォールバック
    - [ ]（任意）バックアップ用に破損文字列を別キーへ退避（デバッグ用）
  - [ ] 容量超過時：
    - [ ] 保存を中断し、ユーザーに「古いデータ削除/エクスポート」等の案内（Phase 4で対応でもOK）
  - [ ] 二重送信防止（連打で複数保存されるのを抑止：ボタン一時無効化など）
- 変更対象（想定ファイル/モジュール）：
  - `js/app.js`
- 受け入れ基準（完了条件）：
  - 想定される例外でアプリが停止しない
  - ユーザーに次の行動（入力修正/再試行/データ削除等）が伝わる
- テスト/検証：
  - 故意に壊したJSONを投入しても起動できる
  - 例外が起きても画面操作が続けられる
- 依存関係・注意点：
  - 今後の「オフライン同期（Phase 4）」と衝突しないよう、保存失敗時の扱いを明確化しておく
- リスクと回避策：
  - リスク：異常系を握りつぶしてデータ喪失に気づけない
  - 回避策：ユーザー通知＋console警告（開発中）＋必要ならログ収集の仕組みを後続で検討

### Plan 4: 手動テスト観点の整備（チェックリスト化）
- 目的：実装後すぐに品質を担保できるよう、再現性のある検証手順を残す。
- 作業内容（チェックリスト）：
  - [ ] 正常系：複数メンバーで3件以上保存→リロード→件数維持
  - [ ] 範囲外：systolic=49 / diastolic=151 / pulse=39 などでエラー
  - [ ] 整合性：systolic=80, diastolic=90 でエラー
  - [ ] 必須抜け：member未選択/日時空でエラー
  - [ ] クリア：入力後にクリア→日時が現在に戻る
  - [ ] 破損データ：localStorageに不正JSON→起動できる（初期化される）
  - [ ] 容量超過（可能なら）：大量データ投入→保存失敗時のメッセージ確認
- 変更対象（想定ファイル/モジュール）：
  - `README.md` もしくは `js/app.js` コメント（どちらかにテスト観点を残す）
- 受け入れ基準（完了条件）：
  - チェックリストに沿ってテストでき、少なくとも「保存/復元/バリデーション/クリア」が担保される
- テスト/検証：
  - チェックリストを実施し、結果（OK/NG）をメモできる状態
- 依存関係・注意点：
  - Step 1-4（一覧表示）がまだ無い場合は、Applicationタブでの確認手順を明記する
- リスクと回避策：
  - リスク：テストが属人化し、後の改修で回帰が出る
  - 回避策：最低限のチェックリストをREADME等に固定し、Stepごとのコミットで追えるようにする

