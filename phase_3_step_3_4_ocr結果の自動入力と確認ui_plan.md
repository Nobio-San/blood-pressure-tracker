## 前提・要約
- 目的：
  - 血圧計の撮影後にOCRを自動実行し、認識した「最高/最低/脈拍」を入力フォームへ自動入力する。
  - ユーザーが結果を“すぐ確認・修正”できるUI（信頼度表示、色分け、再試行）を提供し、記録ミスと手間を減らす。
- 成果物：
  - OCR実行中のローディング/進捗表示
  - OCR結果の自動入力（フィールド背景色・信頼度%表示）
  - 確認UI（「修正する」「そのまま記録」/再試行/失敗時メッセージ）
  - 編集時に自動入力マークが解除される挙動
- 対象の種類（推定）：
  - **新規機能追加＋既存フロー改修**（撮影→プレビュー→入力の既存導線にOCRステート/UIを追加するため）
- 成功条件（Done）：
  - 撮影画像の「使用」確定後、OCRが自動実行され、完了後にフォームへ値が自動入力される
  - 各フィールドに信頼度%と色分けが表示され、ユーザーが迷わず確認・修正できる
  - ユーザーが編集したフィールドは「自動入力表示」が解除され、最終保存値が編集内容になる
  - OCR失敗時は画像を保持したまま、手動入力/再試行ができる
  - 主要端末（Android Chrome）でUIが崩れず、処理中に操作不能・フリーズしない
- 前提（仮定した点があれば明記）：
  - Step 3-1〜3-3が完了しており、`js/ocr.js`に「画像→抽出結果」を返す関数が存在（例：`recognizeText()`＋抽出関数）
  - Phase 2の撮影フロー（`js/camera.js`）から「確定した画像（Base64/Blob/canvas）」を`app.js`へ渡せる
  - 既存フォームは`app.js`で状態管理・保存（localStorage/Sheets連携）を行っている
- 主要な制約：
  - PWA/モバイル前提（タップ領域、表示密度、ローディングの体感）
  - OCRはクライアント実行（Tesseract.js）で時間/メモリ負荷がある
  - OCR信頼度は「全体」だけでなく「項目別」にない可能性がある（UIは推定で対応）
- 既知の不明点（あれば）：
  - OCRの「進捗」をどの粒度で取得できるか（workerのlogger等）
  - 血圧計の表示レイアウト差により、項目別信頼度が算出できない場合のUX方針

## 全体ステップ構成
- Step1: UI/UX仕様の確定（状態・表示・導線を固める）
- Step2: OCRステート管理の土台実装（状態遷移・イベント結線）
- Step3: OCR自動実行と入力フォーム自動反映（自動入力・装飾）
- Step4: 確認UI（アクション群）実装（修正/そのまま記録/再試行）
- Step5: 失敗・低信頼度時の扱い強化（フォールバック、メッセージ）
- Step6: テスト/微調整（実機・エッジケース・アクセシビリティ）

---

## Step1: UI/UX仕様の確定（状態・表示・導線を固める）
### Plan 1: 画面状態（State）と遷移図を作成
- 目的：
  - 実装前に「いつ何を表示するか」を確定し、後戻りを減らす。
- 作業内容（チェックリスト）：
  - [ ] OCRの状態を定義：`idle` / `running` / `success` / `failed`
  - [ ] 画像状態を定義：`noImage` / `hasImage`（プレビュー済み/破棄等）
  - [ ] 遷移トリガーを定義：撮影確定、再試行、画像破棄、保存、手動編集
  - [ ] UI要素を状態に紐づけ：スピナー、進捗、結果バナー、ボタン活性/非活性
  - [ ] 低信頼度の閾値（緑/黄/赤）を決定（既定：>90, 70-90, <70）
- 変更対象（想定ファイル/モジュール）：
  - `README.md`（短い仕様メモとして追記推奨）
  - （任意）`docs/ocr-ui.md` を追加
- 受け入れ基準（完了条件）：
  - 状態一覧・遷移・各状態で表示されるUIが1枚（または1ページ）にまとまっている
- テスト/検証：
  - 机上で主要シナリオ（成功/失敗/再試行/編集）をトレースして矛盾がない
- 依存関係・注意点：
  - OCRの進捗取得可否によって進捗UIの仕様が変わる可能性あり
- リスクと回避策：
  - リスク：仕様が曖昧なまま実装が分岐だらけになる
  - 回避策：状態とUIの対応表を最初に固定してから着手

### Plan 2: UI部品の配置と文言を確定
- 目的：
  - 高齢者も含む利用を想定し、「何をすれば良いか」が明確なUIにする。
- 作業内容（チェックリスト）：
  - [ ] ローディング文言（例：「読み取り中…」）
  - [ ] 成功時バナー文言（例：「認識結果を確認してください」）
  - [ ] 失敗時バナー文言（例：「自動読み取りに失敗しました。手動で入力するか再試行してください」）
  - [ ] ボタン文言：再試行/修正する/そのまま記録
  - [ ] 信頼度表示形式：`92%`（項目横）＋全体の概算（任意）
- 変更対象（想定ファイル/モジュール）：
  - `index.html`, `css/style.css`
- 受け入れ基準（完了条件）：
  - 主要な表示文言と配置が決まり、実装者が迷わない
- テスト/検証：
  - スマホ表示で文字が小さすぎない（16px以上）・ボタンが押しやすい（>=44px）
- 依存関係・注意点：
  - 既存のフォームUIと干渉しないよう、バナーはフォーム上部の「画像プレビュー下」に置く想定
- リスクと回避策：
  - リスク：情報量過多
  - 回避策：デフォルトは簡潔にし、詳細（rawText等）は開発モードのみ

---

## Step2: OCRステート管理の土台実装（状態遷移・イベント結線）
### Plan 1: OCR実行コントローラ（app側）を実装
- 目的：
  - `app.js`に「OCRを開始/完了/失敗」までの一連の制御（状態）を持たせる。
- 作業内容（チェックリスト）：
  - [ ] `app.js`にOCR用の状態（例：`ocrStatus`, `ocrResult`, `ocrError`, `ocrProgress`）を追加
  - [ ] 「撮影画像の使用確定」イベントからOCR開始関数を呼び出す結線
  - [ ] 連打対策：OCR実行中は再実行・保存ボタン等を適切に制御
  - [ ] OCR完了時にUI更新イベント（DOM更新）を集約する（関数化）
- 変更対象（想定ファイル/モジュール）：
  - `js/app.js`, `js/camera.js`（画像確定イベントの受け渡しが必要な場合）
- 受け入れ基準（完了条件）：
  - OCR開始→成功/失敗で状態が正しく遷移し、UI更新が一箇所にまとまっている
- テスト/検証：
  - 開発者ツールで状態ログを確認（実行中に二重実行しない）
- 依存関係・注意点：
  - `ocr.js`側のAPI（関数名/引数/戻り値）をStep 3-3の構造に合わせる
- リスクと回避策：
  - リスク：DOM更新が散らかってバグ温床
  - 回避策：`renderOcrUI(state)`のように集約

### Plan 2: ocr.jsに「進捗/キャンセル」拡張の余地を作る
- 目的：
  - ローディング体験改善のため、進捗表示（可能なら）とキャンセル（最低限：無視）を設計に入れる。
- 作業内容（チェックリスト）：
  - [ ] `ocr.js`の実行関数に `onProgress` コールバックを渡せる形にする（取得できない場合はno-op）
  - [ ] 実行中に画像が破棄された場合、結果を破棄する（キャンセル相当）
  - [ ] 例外を握りつぶさず、`app.js`へエラー情報を返す
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`
- 受け入れ基準（完了条件）：
  - OCR中の状態更新が可能（少なくとも開始/終了/失敗）で、後から進捗UIを追加しやすい
- テスト/検証：
  - 失敗を意図的に起こした場合（不正画像/空画像）にエラーがUIへ反映される
- 依存関係・注意点：
  - Tesseract.jsのlogger利用可否に依存
- リスクと回避策：
  - リスク：進捗実装に時間がかかる
  - 回避策：まずはスピナーのみで完了、進捗はオプションで段階導入

---

## Step3: OCR自動実行と入力フォーム自動反映（自動入力・装飾）
### Plan 1: OCR成功時にフォームへ自動入力
- 目的：
  - `ocrResult`（抽出済み）をフォーム入力欄へ反映し、ユーザーの入力手間を削減する。
- 作業内容（チェックリスト）：
  - [ ] `systolic/diastolic/pulse` の各inputへ値をセット
  - [ ] 「自動入力」扱いのメタ情報を保持（例：data属性 `data-autofilled=true`）
  - [ ] フォームバリデーション（範囲/大小関係）を再実行し、範囲外は警告扱い
  - [ ] 自動入力されたフィールドの見た目（背景色/枠線）を適用
- 変更対象（想定ファイル/モジュール）：
  - `js/app.js`, `index.html`, `css/style.css`
- 受け入れ基準（完了条件）：
  - OCR成功で3項目が自動入力され、視覚的に「自動入力だ」と分かる
- テスト/検証：
  - 正常画像で自動入力される
  - 異常値（範囲外）を返した場合に警告表示になる（保存がブロックされる/注意表示、方針に従う）
- 依存関係・注意点：
  - 既存のフォームバリデーションと衝突しないようにする
- リスクと回避策：
  - リスク：自動入力で誤値が入るとそのまま保存されやすい
  - 回避策：Step4の確認UIで「確認を促す」＆低信頼度は強い色で注意

### Plan 2: 信頼度に応じた色分け・信頼度%表示
- 目的：
  - ユーザーが「どこを重点的に確認すべきか」を直感的に理解できるようにする。
- 作業内容（チェックリスト）：
  - [ ] 信頼度しきい値でクラス付与（`confidence-high/mid/low`）
  - [ ] 各inputの横にバッジで`XX%`表示（項目別が無い場合は全体信頼度を共通表示）
  - [ ] 色覚多様性に配慮し、色＋アイコン/ラベル（例：✓/!/✕）も併用
  - [ ] CSSでスマホでも崩れないレイアウト（2行折返し許容）
- 変更対象（想定ファイル/モジュール）：
  - `index.html`, `css/style.css`, `js/app.js`
- 受け入れ基準（完了条件）：
  - 信頼度に応じて見た目が変わり、各項目に%が表示される
- テスト/検証：
  - しきい値境界（70/90）で期待通りの色になる
  - 小さい画面幅でもバッジが押し出されない
- 依存関係・注意点：
  - 「項目別信頼度が取れない」場合の代替仕様をStep1で決めておく
- リスクと回避策：
  - リスク：色だけに依存して伝わらない
  - 回避策：アイコン/文言を併用

---

## Step4: 確認UI（アクション群）実装（修正/そのまま記録/再試行）
### Plan 1: 確認バナーとアクションボタン実装
- 目的：
  - OCR結果が入った直後に「次に何をするか」を明確化し、誤記録を防ぐ。
- 作業内容（チェックリスト）：
  - [ ] 成功時バナーを表示（例：「認識結果を確認してください」）
  - [ ] ボタン群：
    - [ ] 「修正する」＝該当フィールドへフォーカス（または編集ガイド表示）
    - [ ] 「そのまま記録」＝保存処理へ進む（既存の記録ボタンを押下相当でもOK）
  - [ ] OCR実行中は保存系ボタンを無効化（または確認ダイアログ）
- 変更対象（想定ファイル/モジュール）：
  - `index.html`, `css/style.css`, `js/app.js`
- 受け入れ基準（完了条件）：
  - OCR成功後にバナーとボタンが表示され、押下で期待通りに遷移/動作する
- テスト/検証：
  - 「そのまま記録」で保存される値がOCR入力値になっている
  - OCR実行中は「そのまま記録」を押せない（または押しても無視/警告）
- 依存関係・注意点：
  - 既存の「記録する」ボタンと役割が重複しないよう、UI優先度を整理
- リスクと回避策：
  - リスク：ボタンが多くて迷う
  - 回避策：基本導線は「そのまま記録」を主ボタン、修正は副ボタン

### Plan 2: 手動編集時の“自動入力表示解除”
- 目的：
  - ユーザーが編集した項目が「確定している」ことを明確にし、誤解を防ぐ。
- 作業内容（チェックリスト）：
  - [ ] inputの`input/change`イベントで、該当フィールドの`data-autofilled`を解除
  - [ ] 解除したフィールドは背景色を通常へ戻す
  - [ ] 信頼度バッジは「—」にする/非表示にする/薄くする（仕様で決定）
  - [ ] 一括解除（ユーザーが全項目を編集開始したらバナーを「修正中」に変更、等）を検討
- 変更対象（想定ファイル/モジュール）：
  - `js/app.js`, `css/style.css`
- 受け入れ基準（完了条件）：
  - 1文字でも編集したら、そのフィールドの自動入力装飾が解除される
- テスト/検証：
  - 編集→保存で編集値が保存される
  - 編集後に再試行した場合の挙動が仕様通り（上書き確認の有無など）
- 依存関係・注意点：
  - 再試行で上書きするなら、編集済みフィールドの扱い（全上書き/未編集のみ上書き）を決める
- リスクと回避策：
  - リスク：再試行で編集が消えて不満
  - 回避策：再試行時に「上書き」確認 or 「未編集のみ上書き」オプション（簡易版は後者推奨）

### Plan 3: 再試行（Retry）ボタンの実装
- 目的：
  - 認識失敗/低精度時に、ユーザーが簡単に再実行できるようにする。
- 作業内容（チェックリスト）：
  - [ ] 失敗時/低信頼度時に「再試行」ボタンを表示
  - [ ] 再試行時、現在の画像（ROI含む）でOCRを再実行
  - [ ] 再試行中のUI（スピナー）を表示し、二重実行を防止
  - [ ] 再試行成功時は結果を反映（上書きルールはPlan 2の方針に従う）
- 変更対象（想定ファイル/モジュール）：
  - `js/app.js`, `js/ocr.js`, `index.html`, `css/style.css`
- 受け入れ基準（完了条件）：
  - 失敗時に再試行でき、成功するとフォームが更新される
- テスト/検証：
  - 連続で再試行を押しても多重実行しない
- 依存関係・注意点：
  - 画像が破棄されている場合は再試行不可にする（ボタン非表示）
- リスクと回避策：
  - リスク：負荷が高く端末が重い
  - 回避策：再試行回数を制限（例：連続3回まで）＋撮影し直し案内

---

## Step5: 失敗・低信頼度時の扱い強化（フォールバック、メッセージ）
### Plan 1: OCR失敗時のフォールバック導線
- 目的：
  - 認識できないケースでもユーザーが詰まらず手動入力へ移行できるようにする。
- 作業内容（チェックリスト）：
  - [ ] 失敗バナー表示＋手動入力を促す
  - [ ] 画像プレビューは保持（拡大表示/再撮影導線は既存を活用）
  - [ ] 失敗時でも入力フォームは利用可能にする
  - [ ] 失敗理由（可能なら）を短く表示（例：タイムアウト/解析失敗）
- 変更対象（想定ファイル/モジュール）：
  - `js/app.js`, `index.html`, `css/style.css`, `js/ocr.js`
- 受け入れ基準（完了条件）：
  - OCR失敗でもユーザーが手動入力して保存できる
- テスト/検証：
  - 画像に文字が少ない/真っ黒等で失敗してもUIが崩れない
- 依存関係・注意点：
  - `ocr.js`がエラー種別を返せるとUX向上（必須ではない）
- リスクと回避策：
  - リスク：失敗が多いとユーザーが離脱
  - 回避策：撮影のコツ（明るさ/反射/枠内）を短く表示（詳細はPhase4 helpでも可）

### Plan 2: 低信頼度時の注意喚起と保存ガード（必要なら）
- 目的：
  - 誤入力のまま保存されるリスクを下げる。
- 作業内容（チェックリスト）：
  - [ ] 低信頼度（<70）を検知したら、バナーで「要確認」強調
  - [ ] （任意）保存時に確認ダイアログを出す（低信頼度項目がある場合のみ）
  - [ ] （任意）範囲外の値は保存をブロックし、修正を促す
- 変更対象（想定ファイル/モジュール）：
  - `js/app.js`, `css/style.css`
- 受け入れ基準（完了条件）：
  - 低信頼度のときにユーザーが気づける（見落としにくい）
- テスト/検検証：
  - 低信頼度のダミー値で保存ガードが動く
- 依存関係・注意点：
  - ガードを強くし過ぎるとUXが悪化するため、最初は「警告のみ」でも可
- リスクと回避策：
  - リスク：毎回ダイアログで煩わしい
  - 回避策：閾値・挙動は設定化（将来） or 初期は控えめに

---

## Step6: テスト/微調整（実機・エッジケース・アクセシビリティ）
### Plan 1: 主要シナリオの動作確認（手動テスト手順を整備）
- 目的：
  - 実機での体感とバグを早期に潰し、次の精度最適化（Step 3-5）へスムーズに繋ぐ。
- 作業内容（チェックリスト）：
  - [ ] 成功シナリオ：撮影→OCR→自動入力→そのまま記録
  - [ ] 修正シナリオ：自動入力→一部修正→保存
  - [ ] 失敗シナリオ：OCR失敗→再試行→（成功/失敗）→手動入力
  - [ ] 低信頼度：黄色/赤の表示→注意喚起の確認→保存
  - [ ] 多重操作：OCR中に連打/画面戻る/画像破棄
  - [ ] レスポンシブ：小画面でUI崩れなし
- 変更対象（想定ファイル/モジュール）：
  - `README.md`（テスト手順追記）
- 受け入れ基準（完了条件）：
  - 上記シナリオが全て通り、致命的な詰まりがない
- テスト/検証：
  - Android Chrome実機で確認（可能なら家族端末も）
- 依存関係・注意点：
  - OCR処理時間が長い端末でローディング表示が必須
- リスクと回避策：
  - リスク：端末差で体感が大きく変わる
  - 回避策：処理時間のログを取り、必要なら画像サイズやROIを調整（Step 3-5へ）

### Plan 2: 例外・パフォーマンスの最低限チューニング
- 目的：
  - UIフリーズやメモリリークの兆候を潰し、継続利用できる品質にする。
- 作業内容（チェックリスト）：
  - [ ] OCR実行時間の計測ログ（開始/終了、ms）
  - [ ] OCR中にUIが固まって見えないよう、DOM更新タイミングを調整（開始時に必ず描画）
  - [ ] 連続実行時にworker/メモリが増え続けないか確認（ワーカー再利用/解放方針を明記）
  - [ ] 例外発生時に必ず`failed`へ遷移し、操作不能にならない
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`, `js/app.js`
- 受け入れ基準（完了条件）：
  - OCRを複数回試しても、極端な速度低下/クラッシュが発生しない
- テスト/検証：
  - 連続5回程度の撮影→OCR→再試行を行い、体感とメモリ挙動を確認
- 依存関係・注意点：
  - ワーカーのライフサイクル（初期化コスト vs メモリ）を意識
- リスクと回避策：
  - リスク：低スペック端末でタイムアウト
  - 回避策：タイムアウト（例：xx秒）を設けて失敗導線へ（将来改善）

