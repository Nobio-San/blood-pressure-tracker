## 前提・要約
- 目的：撮影した血圧計画像に対して、Tesseract.jsで文字認識（OCR）できる最小構成を導入し、以降（前処理・抽出・UI連携）の土台を作る
- 成果物：
  - `index.html` にTesseract.js（CDN）読み込みを追加
  - `js/ocr.js` を新規作成し、ワーカー初期化・OCR実行・結果返却の最小APIを提供
  - ローカル環境（PC/Android Chrome）での疎通確認手順（README追記 or 開発メモ）
- 対象の種類（推定）：新規機能追加（OCR基盤の新規導入）
  - 根拠：Phase 3 Step 3-1で `js/ocr.js` 新規作成と `index.html` への追加が明記されているため
- 成功条件（Done）：
  - ブラウザでTesseract.jsが読み込まれ、OCRワーカーが初期化できる
  - `recognizeText(image)` が実行でき、認識テキスト（raw）と信頼度（confidence）を返せる
  - `tessedit_char_whitelist` と PSM などの基本設定が反映されていることを確認できる
- 前提（仮定した点があれば明記）：
  - 既存構成はビルドなしの素のHTML/JS（scriptタグ読み込み）で進める
  - 画像は `camera.js` 側で取得した Base64 / Blob / canvas など、Tesseractが受け取れる形式に変換して渡す（このStepではAPI受け口を広めに取る）
  - 言語データ（`jpn`/`eng`）はまずCDN配信を利用し、PWAオフライン最適化（ローカル配置・キャッシュ）は後続Stepで扱う
- 主要な制約：
  - Android（PWA）で動作すること
  - 初回実行時に言語データ取得が発生し得るため、通信環境・ロード時間に配慮
  - OCRは重い処理なので、ワーカーは基本的にシングルトンで再利用する
- 既知の不明点（あれば）：
  - デプロイ先（GitHub Pages / 自宅サーバ / Firebase Hosting等）とCORS/キャッシュ方針
  - 血圧計の表示フォント/レイアウト（PSM最適値に影響）

## 全体ステップ構成
- Step1: 導入方針の確定（CDN/言語データ/呼び出しI/Fを決める）
- Step2: `index.html` へTesseract.js読み込みを追加（ロード順・defer整理）
- Step3: `js/ocr.js` を新規実装（ワーカー初期化・設定・OCR実行API）
- Step4: 疎通テスト用の最小フックを追加（開発時のみ）
- Step5: 開発メモ/README整備（使い方・制約・トラブルシュート）

---

## Step1: 導入方針の確定（CDN/言語データ/呼び出しI/F）
### Plan 1: Tesseract.js導入方式とバージョン固定
- 目的：後から挙動が変わらないよう、読み込み元とバージョンを固定し、言語データ取得経路も合わせて決める
- 作業内容（チェックリスト）：
  - [ ] Tesseract.jsの配信元（例：jsDelivr/cdnjs）を決める
  - [ ] バージョンを固定（例：`tesseract.js@x.y.z`）する
  - [ ] `jpn` + `eng` の言語データ取得方針を決める（まずCDN、将来はローカル配置も可）
  - [ ] 失敗時の典型原因（CORS/404/サイズ）をメモ化
- 変更対象（想定ファイル/モジュール）：
  - `index.html`（scriptタグ）
  - `README.md`（導入メモ）
- 受け入れ基準（完了条件）：
  - バージョン固定のURLが決まっている
  - `langPath` をCDN指定する/しないの方針が決まっている
- テスト/検証：
  - ブラウザで対象CDNにアクセスできる（ネットワークタブで取得確認）
- 依存関係・注意点：
  - 将来PWAオフラインを強くする場合、言語データのローカル配信が必要になりやすい
- リスクと回避策：
  - リスク：CDN側の仕様変更で取得できない
  - 回避策：バージョン固定、必要なら言語データを`/tessdata`配下に同梱する設計余地を残す

### Plan 2: `ocr.js` の公開API設計（最小で拡張しやすく）
- 目的：後続Step（前処理/抽出/UI）で困らない、安定した呼び出しI/Fを先に定義する
- 作業内容（チェックリスト）：
  - [ ] `initOcr()`（ワーカー生成・ロード・設定）
  - [ ] `recognizeText(image)`（OCR実行、結果返却）
  - [ ] `terminateOcr()`（ワーカー終了）
  - [ ] 返却値の形（`{ rawText, confidence, data }` など）を決める
  - [ ] 進捗通知（logger）をオプションで受け取れるようにする方針を決める
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`
- 受け入れ基準（完了条件）：
  - app側が「初期化→OCR→破棄」を迷わず呼べるAPIになっている
- テスト/検証：
  - APIのサンプル呼び出し（擬似コード）をREADMEに残す
- 依存関係・注意点：
  - ES Modules化するかどうかで export 方式が変わる（本計画では`window.OCR`公開を想定）
- リスクと回避策：
  - リスク：後でES Modulesへ切り替えたくなる
  - 回避策：`window.OCR`の中身を関数として分離し、移行しやすい構造にする

---

## Step2: `index.html` へTesseract.js読み込みを追加
### Plan 1: scriptタグ追加とロード順整理
- 目的：Tesseractが確実にロードされ、`ocr.js` がそれを利用できる状態を作る
- 作業内容（チェックリスト）：
  - [ ] `index.html` にTesseract.jsのCDN scriptを追加
  - [ ] `js/ocr.js` の読み込みを追加（既存 `app.js` / `camera.js` より前後関係を整理）
  - [ ] `defer` の付与方針を統一（読み込み競合を避ける）
- 変更対象（想定ファイル/モジュール）：
  - `index.html`
- 受け入れ基準（完了条件）：
  - コンソールで `window.Tesseract`（または利用形態に応じたグローバル）が参照できる
  - `ocr.js` 読み込みエラーが出ない
- テスト/検証：
  - DevTools ConsoleでTesseractが存在することを確認
  - NetworkタブでCDNリソースが200で取得できることを確認
- 依存関係・注意点：
  - PWA/Service Workerがすでにある場合、キャッシュが古いと更新が反映されないことがある
- リスクと回避策：
  - リスク：CDNブロックやオフラインで動かない
  - 回避策：後続でローカル配置を検討（このStepではまず導入を優先）

---

## Step3: `js/ocr.js` を新規実装（ワーカー初期化・設定・OCR実行）
### Plan 1: シングルトンワーカーの初期化（`initOcr`）
- 目的：OCR処理の都度初期化せず、パフォーマンスと安定性を確保する
- 作業内容（チェックリスト）：
  - [ ] ワーカーをシングルトンで保持（多重初期化を防ぐ）
  - [ ] `jpn+eng` をロードする
  - [ ] 基本パラメータ設定（例：`tessedit_char_whitelist: '0123456789/'`）
  - [ ] PSMを指定（まずは候補：6 or 7 を採用し、後続Stepで最適化）
  - [ ] 進捗loggerを受け取れるようにする（例：`onProgress`）
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`
- 受け入れ基準（完了条件）：
  - `initOcr()` 実行で例外なく完了し、ワーカーが利用可能になる
  - 初回のみ言語データ取得が走り、以降は再利用される
- テスト/検証：
  - 初回実行時のNetworkで `jpn.traineddata` / `eng.traineddata`（相当）の取得が確認できる
  - 2回目以降の `initOcr()` で無駄な再ロードが発生しない
- 依存関係・注意点：
  - `langPath` の指定が必要な配信元もある（Plan 1で方針確定）
- リスクと回避策：
  - リスク：`jpn` が重く初期化が遅い
  - 回避策：初期化をユーザー操作（撮影後など）に合わせる、もしくはアイドル時に先読み（後続検討）

### Plan 2: OCR実行関数（`recognizeText(image)`）
- 目的：画像を渡してテキスト認識結果を返す最小ユースケースを成立させる
- 作業内容（チェックリスト）：
  - [ ] `recognizeText(image)` を実装（内部で `initOcr()` を保証）
  - [ ] `image` 入力の受け口を広めにする（URL/Base64/canvas/Blobのいずれかを許容する方針）
  - [ ] 返却値に以下を含める：
    - `rawText`（全文）
    - `confidence`（平均信頼度 or 代表値）
    - `data`（必要ならTesseractの生データ）
  - [ ] エラー時は例外 or `null` を統一ルールで返す（呼び出し側が扱いやすい）
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`
- 受け入れ基準（完了条件）：
  - 既知のサンプル画像（血圧計でなくても可）で `rawText` が取得できる
  - whitelist設定により、明らかに関係ない文字の混入が減っている（完全でなくてOK）
- テスト/検証：
  - 1枚の画像を入力して、コンソールで結果が確認できる
- 依存関係・注意点：
  - 画像前処理（Step 3-2）はこのStepでは未実装なので精度は問わない
- リスクと回避策：
  - リスク：入力形式の違いで動かない
  - 回避策：受け口を1つ（例：canvas）に絞り、呼び出し側で統一変換する方針でもよい（その場合はREADMEに明記）

### Plan 3: 終了処理（`terminateOcr`）とメモリリーク対策
- 目的：長時間利用（PWA常駐）でメモリを圧迫しない
- 作業内容（チェックリスト）：
  - [ ] `terminateOcr()` を実装し、ワーカーを破棄できる
  - [ ] 画面離脱/リロード時に破棄する（必要なら `window.addEventListener('beforeunload', ...)`）
  - [ ] 例外時に中途半端な状態を残さない（再初期化可能にする）
- 変更対象（想定ファイル/モジュール）：
  - `js/ocr.js`
  - （必要なら）`js/app.js`
- 受け入れ基準（完了条件）：
  - `terminateOcr()` 呼び出し後に再度 `initOcr()` が正常に動作する
- テスト/検証：
  - terminate→init→recognize の一連が動く
- 依存関係・注意点：
  - Android端末のメモリ状況によっては、ワーカー常駐が不利な場合がある
- リスクと回避策：
  - リスク：頻繁なterminateで初期化が遅くなりUXが悪化
  - 回避策：一定時間アイドルで破棄するなどは後続で検討

---

## Step4: 疎通テスト用の最小フックを追加（開発時のみ）
### Plan 1: デバッグ用「OCRテスト」導線（UI or コンソール）
- 目的：Phase 3に入った直後に「動く/動かない」を即判定できるようにする
- 作業内容（チェックリスト）：
  - [ ] 開発中のみ有効なテスト導線を用意（例：隠しボタン/URLパラメータで表示）
  - [ ] 手元のテスト画像（サンプル）を読み込んで `recognizeText()` を実行
  - [ ] 結果（rawText/confidence）を画面 or console に表示
- 変更対象（想定ファイル/モジュール）：
  - `index.html`（必要ならボタン）
  - `js/app.js` or `js/ocr.js`（テスト呼び出し）
- 受け入れ基準（完了条件）：
  - PC Chrome / Android Chrome の両方で、最低1回OCRが成功する
- テスト/検証：
  - DevToolsのConsoleでエラーがないこと
  - Networkで言語データが取得できていること
- 依存関係・注意点：
  - 実機（Android）では初回ロードが遅いので、ローディング表示はStep 3-4で本格対応予定
- リスクと回避策：
  - リスク：テスト導線が本番に残る
  - 回避策：`DEBUG` フラグでガードし、READMEに削除/無効化手順を明記

---

## Step5: 開発メモ/README整備
### Plan 1: 導入手順・制約・トラブルシュートの明文化
- 目的：後続Stepや将来メンテで迷わないよう、導入の勘所を残す
- 作業内容（チェックリスト）：
  - [ ] 追加したscriptタグとバージョン情報を記載
  - [ ] 初回に言語データ取得が走る点（サイズ/時間）を記載
  - [ ] よくある失敗（CORS/404/Service Workerキャッシュ）と対処を記載
  - [ ] `OCR.initOcr` / `OCR.recognizeText` の使い方例を記載
- 変更対象（想定ファイル/モジュール）：
  - `README.md`
- 受け入れ基準（完了条件）：
  - 新規端末で導入しても、READMEだけで疎通できる
- テスト/検証：
  - READMEの手順をなぞって再現できる
- 依存関係・注意点：
  - PWAキャッシュの影響で更新が反映されない場合の注意書きが重要
- リスクと回避策：
  - リスク：ドキュメントが陳腐化
  - 回避策：Phase完了時にREADMEの更新をチェックリスト化（運用ルール）

